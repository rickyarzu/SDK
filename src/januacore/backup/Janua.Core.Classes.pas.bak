unit Janua.Core.Classes;

interface

{$I JANUACORE.INC}

uses

{$IFDEF delphixe}
  // System Procedures ............................................................
  System.SysUtils, System.Classes, System.Bindings.Expression, System.Bindings.Helper, System.Rtti, System.IOUtils,
  System.Variants, System.StrUtils, System.TypInfo, System.Generics.Collections, System.JSON, System.Types,
  // Custom Units ......................................................................................................
{$ELSE}
  Process,
{$ENDIF delphixe}

{$IF Defined(Posix)}
  Posix.Stdlib,
  // ReqMulti is the multipart content parser of delphi XE
{$ENDIF Posix}
{$IFDEF MACOS} MacApi.CoreFoundation,
{$IFNDEF IOS} MacApi.AppKit, MacApi.CocoaTypes, MacApi.Foundation, {$ENDIF}
{$ENDIF}
{$IF Defined(MSWINDOWS)}
  Winapi.Windows, Winapi.ShellAPI, Winapi.ShlObj, Winapi.ActiveX,
  // ReqMulti is the multipart content parser of delphi XE
{$ENDIF}
{$IF Defined(WEBBROKER)}
  Web.HttpApp, ReqMulti,
{$ENDIF}
{$IFDEF FPC}
{$MODESWITCH ADVANCEDRECORDS}
  // system ...................................................................
  SysUtils, Classes, TypInfo, Types, Variants, fpjson, jsonparser,  Generics.Collections, StrUtils,
  // DB .......................................................................
  DB,  VirtualTable,
  // HTTP .....................................................................
  fphttpclient,
{$ENDIF}
{$IFNDEF FPC}
  // http functions
  System.Net.HttpClient, System.Net.URLClient, System.Net.Mime,
  System.Net.HttpClientComponent,
  System.NetEncoding,

  // DB Units
  Datasnap.DBClient, Data.DB,    FireDAC.Comp.Client,
// Spring
Spring.Collections,
{$ENDIF}
  // Indy
  IdURI,

  // Januaproject
  Janua.Core.Types, Janua.Http.Types, Janua.Orm.Types, Janua.Controls.Standard.Intf;

{$TYPEINFO ON}
{$METHODINFO ON}

type
  TJanuaCoordinates = record
  private
    FCoordinates: TJanuaRecordCoordinates;
    function getLatitude: Double;
    function getLongitude: Double;
    function getAddress: string;
    procedure SetLatitude(const Value: Double);
    procedure SetLongitude(const Value: Double);
    procedure SetAddress(const Value: string);
    procedure SetCoordinates(const Value: TJanuaRecordCoordinates);
  public
    constructor Create(aLat, aLon: Double);
    function ToString: string;
    procedure Clear;
    procedure GetCoordinatesFromAddress;
    property Coordinates: TJanuaRecordCoordinates read FCoordinates write SetCoordinates;
    property Latitude: Double read getLatitude write SetLatitude;
    property Longitude: Double read getLongitude write SetLongitude;
    property Address: string read getAddress write SetAddress;
  end;

Type
  TJanuaMime = class(TPersistent)
  private
    FCharset: TJanuaCharsetType;
    FMimeType: TJanuaMimeType;
    FExtension: string;
    FMimeList: TStrings;
    FCharSetList: TStrings;
    procedure SetCharset(const Value: TJanuaCharsetType);
    procedure SetCharsetString(const Value: string);
    procedure SetMimeString(const Value: string);
    procedure SetMimeType(const Value: TJanuaMimeType);
    procedure SetExtension(const Value: string);
    procedure SetMimeList(const Value: TStrings);
    procedure SetCharSetList(const Value: TStrings);
    function getCharsetString: string;
    function getMimeString: string;
    function getIsSet: boolean;
  public
    constructor Create; overload;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
  published
    property MimeString: string read getMimeString write SetMimeString;
    property MimeType: TJanuaMimeType read FMimeType write SetMimeType default jmtUnknown;
    property CharsetString: string read getCharsetString write SetCharsetString;
    property Charset: TJanuaCharsetType read FCharset write SetCharset;
    property Extension: string read FExtension write SetExtension;
    property MimeList: TStrings read FMimeList write SetMimeList;
    property CharSetList: TStrings read FCharSetList write SetCharSetList;
    property isSet: boolean read getIsSet;
  end;

type
  TJanuaJsonParser = class
  private
    FIndex: TDictionary<string, TJsonValue>;
    FAsJsonString: string;
    FasJsonObject: TJsonObject;
    procedure SetasJsonObject(const Value: TJsonObject);
    procedure SetAsJsonString(const Value: string);
  public
    Constructor Create; overload;
    Constructor Create(aObject: TJsonObject); overload;
    Destructor Destroy; override;
    function FindKey(aKey: string): TJsonValue;
  public
    // This function Stores a Value into a Json Variable ......................................
    procedure JsonValue(aParam: string; var aValue: string); overload;
    procedure JsonValue(aParam: string; var aValue: TDateTime); overload;
    procedure JsonValue(aParam: string; var aValue: Int64); overload;
    procedure JsonValue(aParam: string; var aValue: integer); overload;
    procedure JsonValue(aParam: string; var aValue: Extended); overload;
    procedure JsonValue(aParam: string; var aValue: Double); overload;
    procedure JsonValue(aParam: string; var aValue: boolean); overload;
    procedure JsonValue(aParam: string; var aValue: TJsonArray); overload;
    procedure JsonValue(aParam: string; var aValue: TJsonObject); overload;
  public
    property asJsonObject: TJsonObject read FasJsonObject write SetasJsonObject;
    property AsJsonString: string read FAsJsonString write SetAsJsonString;
  end;

type
  TJanuaUserType = (jutND, jutNewUser, jutRegisteredUser);

  /// <summary>
  /// This is a List of all generic objects that will be used in forms and
  /// webforms or webpages
  /// </summary>
  TJanuaComponentTypes = (
    /// <summary>
    /// A Form
    /// </summary>
    jotForm,

    /// <summary>
    /// A Button that can be just a Button or a Switch
    /// </summary>
    jotButton,

    /// <summary>
    /// Normal Label or html Label or Mixed Label
    /// </summary>
    jotLabel,

    /// <summary>
    /// Edit box containing Text or password or whatever else
    /// </summary>
    jotEdit,

    /// <summary>
    /// Text displayer with no editable capabilities can be dynamic (linked to
    /// database) or completely static
    /// </summary>
    jotText,

    /// <summary>
    /// The memo is usually connected as part of an editor
    /// </summary>
    jotMemo,

    /// <summary>
    /// A Container: Panel, Region or Shader
    /// </summary>
    jotRegionPanel,

    /// <summary>
    /// a Standard Link component to a Url
    /// </summary>
    jotLinkUrl,

    /// <summary>
    /// An Html Formatted Text
    /// </summary>
    jotHtmlText,

    /// <summary>
    /// An Image Component
    /// </summary>
    jotImage);

  TJanuaFormDef = (
    /// <summary>
    /// Non selezionato
    /// </summary>
    jwsNone,

    /// <summary>
    /// Unibacheca Home
    /// </summary>
    jwsUniHome,

    /// <summary>
    /// Unibacheca Intro
    /// </summary>
    jwsUniIntro,

    /// <summary>
    /// Virtual Classroom
    /// </summary>
    jwsVirtualClassRoom,

    jwsUniLogin,

    jwsUniBookSearch,

    jwsUniBookInsert,

    jwsUniBookManage,

    jwsUniBookShow,

    jwsUniRoomSearch,

    jwsUniRoomInsert,

    jwsUniRoomManage,

    jwsUniRoomShow,

    jwsRegisterStart,

    jwsRegisterStudent,

    jwsRegisterPrivate,

    jwsRegisterCompany,

    jwsRegisterEnd,

    jwsUniHtmlPage,

    jwsUniNews,

    jwsUniWriteArticle,

    jwsUniPublish,

    jwsUniSearch,

    jwsUniAbout,

    jwsHayHome,

    jwsHayAbout,

    jwsHealthLogin,

    jwsHealthRegistration,

    jwsHealthHome

    );

type
  TJanuaConfType = (jfcUnknown, jcfString, jcfBoolean, jcfInteger, jcfLargeInt, jcfDouble, jcfDate,
    jcfDateTime, jcfServerConf);

const
  JanuaConfType: array [TJanuaConfType] of string = ('', 'String', 'Boolean', 'Integer', 'LargeInt', 'Double',
    'Date', 'DateTime', 'ServerConf');

function DecodeJanuaConfType(sType: string): TJanuaConfType;

type
  TJanuaConfValue = record
    Key: string;
    ValueType: TJanuaConfType;
  private
    iValue: integer;
    bValue: boolean;
    lValue: Int64;
    dValue: Double;
    dtValue: TDate;
    dttValue: TDateTime;
    rcValue: TJanuaServerRecordConfs;
  private
    FsValue: string;
    function getAsInteger: integer;
    function getAsString: string;
    function getAsJsonObject: TJsonObject;
    procedure setAsInteger(const Value: integer);
    procedure SetasJsonObject(const Value: TJsonObject);
    procedure setAsString(const Value: string);
    procedure SetsValue(const Value: string);
  public
    property AsInteger: integer read getAsInteger write setAsInteger;
    property AsString: string read getAsString write setAsString;
    property asJsonObject: TJsonObject read getAsJsonObject write SetasJsonObject;
    property sValue: string read FsValue write SetsValue;
  public
    procedure Clear;
    constructor Create(aKey: string; aValue: boolean); overload;
    constructor Create(aKey: string; aValue: string); overload;
    constructor Create(aKey: string; aValue: Int64); overload;
    constructor Create(aKey: string; aValue: integer); overload;
    constructor Create(aKey: string; aValue: TDate); overload;
    constructor Create(aKey: string; aValue: TDateTime); overload;
    constructor Create(aKey: string; aValue: TJsonObject); overload;
    constructor Create(aKey: string; aValue: TJanuaServerRecordConfs); overload;
  end;

type
  TJanuaConfKey = record
    Key: string;
    items: array of TJanuaConfValue;
    ItemIndex: integer;
  private
    function getAsJsonObject: TJsonObject;
    procedure SetasJsonObject(const Value: TJsonObject);
    function getSelectedItem: TJanuaConfValue;
    procedure SetSelectedItem(const Value: TJanuaConfValue);
  public
    procedure AddItem(aItem: TJanuaConfValue); overload;
    procedure AddItem(aObject: TJsonObject); overload;
    procedure AddItem(aKey: string; aValue: string); overload;
    procedure AddItem(aKey: string; aValue: Int64); overload;
    procedure AddItem(aKey: string; aValue: integer); overload;
    procedure AddDate(aKey: string; aValue: TDate); overload;
    procedure AddItem(aKey: string; aValue: TDateTime); overload;
    procedure AddItem(aKey: string; aValue: boolean); overload;
    procedure AddItem(aKey: string; aValue: TJsonObject); overload;
    procedure AddItem(aKey: string; aValue: TJanuaServerRecordConfs); overload;
    procedure SetItem(aKey: string; aValue: string); overload;
    procedure SetItem(aKey: string; aValue: Int64); overload;
    procedure SetItem(aKey: string; aValue: integer); overload;
    procedure SetItem(aKey: string; aValue: TDate); overload;
    procedure SetItem(aKey: string; aValue: TDateTime); overload;
    procedure SetItem(aKey: string; aValue: boolean); overload;
    procedure SetItem(aKey: string; aValue: TJsonObject); overload;
    procedure SetItem(aKey: string; aValue: TJanuaServerRecordConfs); overload;

  public
    procedure Clear;
    function count: integer;
    constructor Create(aKey: string); overload;
    constructor Create(aKey: string; aItem: TJanuaConfValue); overload;
    constructor Create(aJsonObject: TJsonObject); overload;
    function FindValue(aKey: string): boolean;
  public
    property asJsonObject: TJsonObject read getAsJsonObject write SetasJsonObject;
    property SelectedItem: TJanuaConfValue read getSelectedItem write SetSelectedItem;
  end;

type
  TJanuaConfiguration = record
    Keys: array of TJanuaConfKey;
    ItemIndex: integer;
    FileName: TFileName;
    LastErrorMessage: string;
    HasErrors: boolean;
  private
    FIsLoaded: boolean;
    function getAsJsonObject: TJsonObject;
    procedure SetasJsonObject(const Value: TJsonObject);
    procedure ClearKeys;
  public
    procedure Initialize;
    procedure Clear;
    function isLoaded: boolean;
    procedure UnLoad;
    procedure LoadConfiguration; overload;
    procedure LoadConfiguration(aFileName: TFileName); overload;
    procedure SaveConfiguration; overload;
    procedure SaveConfiguration(aFileName: TFileName); overload;
    function count: integer;
    function FindValue(aKey, aValue: string): boolean;
    function FindKey(aKey: string): boolean;
    constructor Create(aFileName: TFileName); overload;
    procedure AddKey(sKey: string); overload;
    procedure AddKey(aKey: TJanuaConfKey); overload;
    procedure AddKey(aKey: TJsonObject); overload;
    procedure LoadFromFile(aFileName: TFileName);
    function asJsonPretty: string;
    function asJson: string;
    function AsJsonString: string;

    function setValue(aKey, aName, aDefault: string): string; overload;
    function setValue(aKey, aName: string; aDefault: boolean): boolean; overload;
    function setValue(aKey, aName: string; aDefault: integer): integer; overload;
    function setValue(aKey, aName: string; aDefault: Int64): Int64; overload;
    function setValue(aKey, aName: string; aDefault: Double): Double; overload;
    function setValue(aKey, aName: string; aDefault: TDate): TDate; overload;
    function setValue(aKey, aName: string; aDefault: TDateTime): TDateTime; overload;
    function setValue(aKey, aName: string; aDefault: TJsonObject): TJsonObject; overload;
    function setValue(aKey, aName: string; aDefault: TJanuaServerRecordConfs)
      : TJanuaServerRecordConfs; overload;

    function getValue(aKey, aName, aDefault: string): string; overload;
    function getValue(aKey, aName: string; aDefault: boolean): boolean; overload;
    function getValue(aKey, aName: string; aDefault: integer): integer; overload;
    function getValue(aKey, aName: string; aDefault: Int64): Int64; overload;
    function getValue(aKey, aName: string; aDefault: Double): Double; overload;
    function getValue(aKey, aName: string; aDefault: TDate): TDate; overload;
    function getValue(aKey, aName: string; aDefault: TDateTime): TDateTime; overload;
    function getValue(aKey, aName: string; aDefault: TJsonObject): TJsonObject; overload;
    function getValue(aKey, aName: string; aDefault: TJanuaServerRecordConfs)
      : TJanuaServerRecordConfs; overload;
  public
    property asJsonObject: TJsonObject read getAsJsonObject write SetasJsonObject;
  end;

type
  TJanuaDisclaimer = record
    About: string;
    Terms: string;
    Privacy: string;
    LastErrorMessage: string;
  public
    function asJsonObject: TJsonObject;
    procedure LoadFromDataset(aDataset: TDataset);
    function SaveToDataset(aDataset: TDataset): boolean;
  end;

type
  TEnumerationEnumerator = class
  private
    FMinValue: integer;
    FMaxValue: integer;
    FValue: integer;
  public
    constructor Create(aEnumeratorTypeInfo: PTypeInfo);
    function GetCurrent: integer;
    function MoveNext: boolean;
    property Current: integer read GetCurrent;
  end;

  REnumerationEnumerator = record
  private
    EnumeratorTypeInfo: PTypeInfo;
  public
    constructor Create(aEnumeratorTypeInfo: PTypeInfo);
    class function From(aEnumeratorTypeInfo: PTypeInfo): REnumerationEnumerator; static;
    function GetEnumerator: TEnumerationEnumerator;
  end;

type
  TJanuaContentType = (jctString, jctJsonObject, jctXml, jctFile, jctImageFile, jctMemo, jctInteger,
    jctCurrency, jctParams, jctMemTable, jctBlob, jctHtml, jctNotSet);

const
  JanuaContentTypeString: array [jctString .. jctNotSet] of string = ('string', 'json', 'xml', 'file',
    'image', 'memo', 'integeger', 'currency', 'params', 'virtualtable', 'html', 'blob', 'notset');

type
  TJanuaRecordSchema = record
    ID: integer;
    Name: string;
    schema_des: string;
    /// <summary>
    /// -- This column tell us if this schema is linked to a person as a
    /// personal schema to store owner's data, password, and profiles
    /// </summary>
    personal: boolean;
    db_schema_key: string;
    country_id: shortint;
    language_id: shortint;
    /// <summary>
    /// Defa
    /// </summary>
    default_user_id: integer;
  public
    procedure Clear;
  end;

type
  TJanuaServerSession = record
    FKey: string;
    Email: string;
    Schema_id: integer;
    Session_id: Int64;
    User_id: integer;
    Social_ID: string;
    Social_Kind: string;
    UserSchemas: array of TJanuaRecordSchema;
    SelectedSchema: TJanuaRecordSchema;
    isPublic: boolean;
  private
    procedure SetasJsonObject(aJsonObject: TJsonObject);
    function getAsJsonObject: TJsonObject;
    procedure SetKey(const Value: string);
  public
    property Key: string read FKey write SetKey;
    property asJsonObject: TJsonObject read getAsJsonObject write SetasJsonObject;
  public
    function ToString: string;
    procedure LoadFromJsonObject(aJsonObject: TJsonObject);
    procedure LoadFromDataset(aDataset: TDataset);
    procedure Clear;
    /// <summary>
    /// Thi method retrieves a schema by its id, if the id provided is not in
    /// the schema list the result is false, else the funcion sets the
    /// Selected Schema and the schema_id field.
    /// </summary>
    /// <param name="aID">
    /// the unique id of the schema
    /// </param>
    /// <returns>
    /// False means not found, True means it is now Set ....
    /// </returns>
    function setSchemaByID(aID: integer): boolean;
    function asJsonPretty: string;
  end;

type
  TJanuaRole = record
    ID: smallint;
    Name: string;
    index: smallint;
    Level: TJanuaRoleLevel;
  end;

type
  TJanuaImageRSSTag = record
    Image: string;
    Url: string;
    Title: string;
    Link: string;
    Width: string;
    Heigth: string;
    Description: string;
  public
    procedure SetDefault;
    constructor Create(aFeedType: TJanuaRSSFeedType);
  end;

type
  TJanuaItemRSSTag = record
    Item: string;
    Title: string;
    Author: string;
    Link: string;
    Description: string;
    category: string;
    comments: string;
    enclosure: string;
    guid: string;
    pubDate: string;
    Source: string;
  public
    procedure SetDefault;
    constructor Create(aFeedType: TJanuaRSSFeedType);
  end;

  {
    Element	Description	Example
    title	The name of the channel. It's how people refer to your service. If you have an HTML website that contains the same information as your RSS file, the title of your channel should be the same as the title of your website.	GoUpstate.com News Headlines
    link	The URL to the HTML website corresponding to the channel.	http://www.goupstate.com/
    description	Phrase or sentence describing the channel.	The latest news from GoUpstate.com, a Spartanburg Herald-Journal Web site.
  }
type
  TJanuaRSSTags = record
    Channel: string;
    Title: string;
    Link: string;
    Description: string;
    Language: string;
    pubDate: string;
    lastBuildDate: string;
    generator: string;
    Item: TJanuaItemRSSTag;
    Image: TJanuaImageRSSTag;
    FeedType: TJanuaRSSFeedType;
  public
    constructor Create(aFeedType: TJanuaRSSFeedType);
    function ToString: string;
  end;

type
  TJanuaFeed = record
    Title, AbstractText, LinkUrl, Text, Image, Author, RawText: unicodestring;
    Date: TDateTime;
  public
    function ToString: string;
  end;

type
  TJanuaFeeds = record
    Url: string;
    RSSTags: TJanuaRSSTags;
    Feeds: array of TJanuaFeed;
  public
    constructor Create(aFeedType: TJanuaRSSFeedType);
    function ToString: string;
  end;

  {

    1 : FJanuaAnagraphType := jatSchoolCustomer;
    2 : FJanuaAnagraphType := jatSchoolSupplier;
    9 : FJanuaAnagraphType := jatAgent;
    10: FJanuaAnagraphType := jatSchoolWorker;
    11: FJanuaAnagraphType := jatSchoolStudent;
    12: FJanuaAnagraphType := jatSchoolGroup;
    13: FJanuaAnagraphType := jatSchoolTeacher;


  }

type
  TArrayRoles = array of TJanuaRole;

  TJanuaUser = record
  private
    FKey: string;
    Frole_name: string;
    FSocialID: string;
    FIsoLanguageCode: string;
    FEmail: string;
    FRoles: TArrayRoles;
    FisPublic: boolean;
    FSelectedRole: TJanuaRole;
    FEmailDate: TDateTime;
    FAvatarImageID: Int64;
    FPayment: boolean;
    FPaymentExpiration: TDate;
    FEmailSent: boolean;
    FSocialType: string;
    FRPassword: string;
    FID: Int64;
    FIsoCultureCode: string;
    Frole_id: smallint;
    FAvatarImageUrl: string;
    FPassword: string;
    FEmailConfirmed: boolean;
    FSocialTypeID: smallint;
    FUsername: string;
    function GetJsonObject: TJsonObject;
    procedure SetAvatarImageUrl(const Value: string);
    procedure SetAvatarImageID(const Value: Int64);
    procedure SetEmail(const Value: string);
    procedure SetEmailConfirmed(const Value: boolean);
    procedure SetEmailDate(const Value: TDateTime);
    procedure SetEmailSent(const Value: boolean);
    procedure SetID(const Value: Int64);
    procedure SetIsoCultureCode(const Value: string);
    procedure SetIsoLanguageCode(const Value: string);
    procedure SetisPublic(const Value: boolean);
    procedure SetKey(const Value: string);
    procedure SetPassword(const Value: string);
    procedure SetPayment(const Value: boolean);
    procedure SetPaymentExpiration(const Value: TDate);
    procedure Setrole_id(const Value: smallint);
    procedure Setrole_name(const Value: string);
    procedure SetRoles(const Value: TArrayRoles);
    procedure SetRPassword(const Value: string);
    procedure SetSelectedRole(const Value: TJanuaRole);
    procedure SetSocialID(const Value: string);
    procedure SetSocialType(const Value: string);
    procedure SetSocialTypeID(const Value: smallint);
    procedure SetUsername(const Value: string);
  public
    procedure Clear;
    procedure LoadFromJsonObject(aJsonObject: TJsonObject);
    function ToString: string;
    function AsRawHtml: string;
    function getRoleByName(aName: string): boolean;
    function GetRolebyIndex(aIndex: integer): boolean;
    function GetRoleByID(aID: integer): boolean;
    procedure SetRoleByID(aID: smallint);
    function ToJSON: string;
{$IFDEF WEBBROKER}
    procedure LoadFromHttpParams(aRequest: TWebRequest);
{$ENDIF}
    procedure LoadFromDataset(dsUser: TDataset);
    procedure SaveToDataset(dsUser: TDataset);
    function AsHtml(aTemplate: string): string;
  public
    property AsSJSONObJect: TJsonObject read GetJsonObject write LoadFromJsonObject;
    property Username: string read FUsername write SetUsername;
    property SocialID: string read FSocialID write SetSocialID;
    property SocialTypeID: smallint read FSocialTypeID write SetSocialTypeID;
    property SocialType: string read FSocialType write SetSocialType;
    property Email: string read FEmail write SetEmail;
    property EmailSent: boolean read FEmailSent write SetEmailSent;
    property EmailDate: TDateTime read FEmailDate write SetEmailDate;
    property EmailConfirmed: boolean read FEmailConfirmed write SetEmailConfirmed;
    property Password: string read FPassword write SetPassword;
    property RPassword: string read FRPassword write SetRPassword;
    property Key: string read FKey write SetKey;
    property ID: Int64 read FID write SetID;
    property role_id: smallint read Frole_id write Setrole_id;
    property role_name: string read Frole_name write Setrole_name;
    property SelectedRole: TJanuaRole read FSelectedRole write SetSelectedRole;
    property Roles: TArrayRoles read FRoles write SetRoles;
    property IsoLanguageCode: string read FIsoLanguageCode write SetIsoLanguageCode;
    property IsoCultureCode: string read FIsoCultureCode write SetIsoCultureCode;
    property AvatarImageID: Int64 read FAvatarImageID write SetAvatarImageID;
    property AvatarImageUrl: string read FAvatarImageUrl write SetAvatarImageUrl;
    property isPublic: boolean read FisPublic write SetisPublic;
    property Payment: boolean read FPayment write SetPayment;
    property PaymentExpiration: TDate read FPaymentExpiration write SetPaymentExpiration;
  end;

type
  TJanuaRecordUserProfile = record
    FUser: TJanuaUser;
    Title: string;
    FirstName: string;
    SecondName: string;
    LastName: string;
    Gender: TJanuaGender;
    BirthDate: TDate;
    PublicEmail: string;
    Address: TJanuaRecordAddress;
    BirthLocation: TRecordLocation;
    FiscalCode: string;
    FacebookJSON: string;
    CellPhone: string;
  private
    function GetJsonObject: TJsonObject;
    procedure SetUser(const Value: TJanuaUser);
  public
    procedure LoadFromJsonObject(aJsonObject: TJsonObject);
    constructor Create(aGender: string);
    function ToString: string;
    function asJson: string;
    function FullName: string;
    function AsHtml(aTemplate: string): string;
    function AsRawHtml: string;
    procedure SaveToDataset(dsUser, dsProfile: TDataset);
    procedure LoadFromDataset(dsUser, dsProfile: TDataset);
{$IFDEF WEBBROKER}
    procedure LoadFromHttpParams(aRequest: TWebRequest);
{$ENDIF}
    procedure Clear;
  public
    property asJsonObject: TJsonObject read GetJsonObject write LoadFromJsonObject;
    // procedura interna al record per il salvataggio su di un Dataset ...........................
    property User: TJanuaUser read FUser write SetUser;
  end;

  TJanuaCustomObject = class(TObject)
  private
    procedure SetName(const Value: string);
  protected
    FName: string;
  public
  published
    property Name: string read FName write SetName;
  end;

  TJanuaCustomPersistent = class(TPersistent)
  private
    procedure SetName(const Value: string);
  protected
    FName: string;
    FActive: boolean;
    procedure SetActive(const Value: boolean); Virtual;
    procedure Deactivate; virtual;
  public
    function Activate: boolean; virtual;
  published
    property Name: string read FName write SetName;
    property Active: boolean read FActive write SetActive stored false;
  end;

type
  TJanuaCustomComponent = class(TComponent)
  strict protected
    FHasErrors: boolean;
    FLastErrorMessage: string;
    // Profile : TJanuaRecordProfile;
  private
    procedure SetHasErrors(const Value: boolean);
  protected
    // FComponents: TObjectList<TJanuaCustomComponent>;
    // Disabilito Temporaneamnte la Gestione dei TPersistents .............................
    // FPersistents: TObjectList<TJanuaCustomPersistent>;
    // FObjects: TObjectList<TJanuaCustomObject>;
  public
    procedure AddObject(aObject: TJanuaCustomObject); virtual;
    procedure DelObject(aObject: TJanuaCustomObject); virtual;
    procedure AddPersistent(aPersistent: TJanuaCustomPersistent); virtual;
    procedure DelPersistent(aPersistent: TJanuaCustomPersistent); virtual;
    procedure AddComponent(aComponent: TJanuaCustomComponent); virtual;
    procedure DelComponent(aComponent: TJanuaCustomComponent); virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property HasErrors: boolean read FHasErrors write SetHasErrors stored false default false;
  end;

  { TJanuaCoreOS }
  TJanuaCoreOS = class(TJanuaCustomComponent)
  public
    class function PublicWriteLog(Sender: TObject; ProcedureName, sMessage: string; isError: boolean = false)
      : TJanuaLogRecord;
    class function PublicWriteError(Sender: TObject; aProcedureName, sMessage: string; E: Exception;
      doraise: boolean = true): TJanuaLogRecord; virtual;
    class function PublicActivate: boolean; virtual;
    class procedure SetupAppConfiguration;
    class Procedure WriteFileText(aFileName: string; aMessage: string);
    // Class Functions ................................................................
    Class function GetSharedDocumentsPath: string;
    Class Function GetDirectory: String;
    Class Function GetTitle: String;
    Class Function GetAppName: string;
    Class Function GetCustomServer: boolean;
    Class Function GetResolveToFile: boolean;
    Class Function GetUseCurrentDir: boolean;
    Class Function GetActive: boolean;
    Class Function GetIsLoaded: boolean;
    Class Function GetLinuxHome: string;
    Class Function GetHomeDirectory: TJanuaOSHomeDir;
    // .................................................................................
    Class procedure SetDirectory(const Value: String);
    Class procedure SetTitle(const Value: String);
    Class procedure SetAppName(const Value: string);
    Class procedure SetCustomServer(const Value: boolean);
    Class procedure SetResolveToFile(const Value: boolean);
    Class procedure SetLinuxHome(const Value: string);
    Class procedure SetHomeDirectory(const Value: TJanuaOSHomeDir);
  private

{$IFDEF MSWINDOWS}
    {
      if we are working in Windows so we will have to Select the right Folder in the system
      for windows XP there will be one kind of selector and for Vista/7 another
      kind of selector.
    }
    (*
      function WinVistaSelectFolder: string;
      function WinXPSelectFolder: string;
    *)
    class function GetComputerNameFromWindows: string;
{$ENDIF}
    procedure CreateConfigDataset;
    procedure SetActive(const Value: boolean);
   {$ifdef delphixe} procedure SetConfigDataset(const Value: TFdMemTable);  {$endif}
   {$ifdef fpc} procedure SetConfigDataset(const Value: TVirtualTable);  {$endif}
  public
    class function GetJsonConf: string;
    class function getOSVersion: string;
    class function GetUserName: String;
    class function getWildCard: string;
    class function GetOsMajor: string;
    class function GetOsName: string;
    class function GetOsPlatform: string;
    class function GetOsString: string;
    class function getDocumentsPath: string;
    (* class function getSeparator: string; *)
    class function GetHomePath: string;
    class procedure SetUseCurrentDir(const Value: boolean);
    class function GetLibraryPath: string;
    class function GetAppDocumentsPath: string;
    class function GetDocDirectory: string;
    class function GetErgoDocumentsPath: string;
    class function GetAppHomePath: string;
    class function GetAppLogPath: string;
    class function GetAppConfPath: string;
    class function GetErgoHomePath: string;
    class function GetErgoTempPath: string;
    class function GetCachePath: string;
    class function GetTempPath: string;
    class function GetAppTempPath: string;
    class function GetLocalComputerName: string;
    class function GetAppDownloadsPath: string;
    class function GetConfigFileName: string;
    class function getCurrentPath: string;
  protected
    function isInitialzing: boolean;
  public
    class procedure Deactivate;
    { Public declarations }
    class function GetConfiguration: string;
    function Activate: boolean;
    class function SelectFolder(var aFolder: string; const aTitle, aButtonCaption: string): boolean;
    class function GetDocumentDirectory: string;
    class function GetDownloadsDirectory: string;
    class function GetOsArchitecture: string;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    class procedure SaveConfiguration;
    class procedure LoadConfiguration;
    class function ReadParam(Key, Name: string; Default: TJanuaServerRecordConfs)
      : TJanuaServerRecordConfs; overload;
    class function WriteParam(Key, Name: string; Default: TJanuaServerRecordConfs)
      : TJanuaServerRecordConfs; overload;
    class function ReadParam(Key, Name: string; Default: TJsonObject): TJsonObject; overload;
    class function ReadParam(Key, Name: string; Default: integer): integer; overload;
    class function ReadParam(Key, Name: string; Default: string): string; overload;
    class function WriteParam(Key, Name: string; Default: string): string; overload;
{$IFDEF MSWINDOWS}
    class function ReadParam(Key, Name: string; Default: AnsiString): AnsiString; overload;
    class function WriteParam(Key, Name: string; Default: AnsiString): AnsiString; overload;
{$ENDIF}
    class function WriteParam(Key, Name: string; Default: integer): integer; overload;
    class function ReadParam(Key, Name: string; Default: boolean): boolean; overload;
    class function WriteParam(Key, Name: string; Default: boolean): boolean; overload;
    class function WriteParam(Key, Name: string; Default: Double): Double; overload;
    class function ReadParam(Key, Name: string; Default: Double): Double; overload;
    class function WriteDateTimeParam(Key, Name: string; Default: TDateTime): TDateTime; overload;
    class function ReadDateTimeParam(Key, Name: string; Default: TDateTime): TDateTime; overload;
    // API to local system calls
    class procedure ExternalExec(FileName, parameter: string);
    class procedure InternalExec(FileName, parameter: string); virtual;
    // property ConfigDataset: TFdMemTable read FConfigDataset write SetConfigDataset;
  private
    class function GetJanuaConfiguration: TJanuaConfiguration;
  published
    // Global Class Properties these properties can be Set only by Conf Class ...........................
    property Title: String read GetTitle write SetTitle stored false;
    property SharedDocumentsPath: string read GetSharedDocumentsPath stored false;
    property AppName: string read GetAppName write SetAppName stored false;
    property CustomServer: boolean read GetCustomServer write SetCustomServer stored false;
    property ResolveToFile: boolean read GetResolveToFile write SetResolveToFile stored false;
    property UseCurrentDir: boolean read GetUseCurrentDir write SetUseCurrentDir stored false;
    property Directory: String read GetDirectory write SetDirectory stored false;
    property LinuxHome: string read GetLinuxHome write SetLinuxHome stored false;
    property HomeDirectory: TJanuaOSHomeDir read GetHomeDirectory write SetHomeDirectory stored false;
    { Published declarations }
    /// <summary>
    /// This is the operating system Versione according to System API
    /// </summary>
    /// <value>
    /// OS version is a string not a number
    /// </value>
    property Version: string read getOSVersion;
    property Username: string read GetUserName;
    property WildCard: String read getWildCard;
    property DocDirectory: String read GetDocDirectory;
    property TempPath: string read GetTempPath;
    property HomePath: string read GetHomePath;
    property LibraryPath: string read GetLibraryPath;
    property CachePath: string read GetCachePath;
    property DownloadsPath: string read GetDownloadsDirectory;
    property AppDocumentsPath: string read GetAppDocumentsPath;
    property ConfigFileName: string read GetConfigFileName;
    property ComputerName: string read GetLocalComputerName;
    property AppHomePath: string read GetAppHomePath;
    property AppDownloadsPath: string read GetAppDownloadsPath;
    property AppTempPath: string read GetAppTempPath;
    property AppDocDirectory: string read GetAppDocumentsPath;
    property AppLogPath: string read GetAppLogPath;
    property LastErrorMessage: string read FLastErrorMessage stored false;
    property Active: boolean read GetActive write SetActive stored false;
    property DocumentsPath: string read getDocumentsPath;
    property OSArchitecture: string read GetOsArchitecture;
    property OSPlatform: string read GetOsPlatform;
    property OSMajor: string read GetOsMajor;
    property OSName: string read GetOsName;
    property OsString: string read GetOsString;
    property ErgoHomePath: string read GetErgoHomePath;
    property CurrentPath: string read getCurrentPath;
    property AppConfPath: string read GetAppConfPath;
    property JsonConf: string read GetJsonConf;
  end;

type
  TJanuaCustomLogger = class(TJanuaCustomComponent)
  private
    FComponent: TComponent;
    FText: string;
    FAutoFileName: boolean;
    FResolveToFile: boolean;
    FIsCustomServer: boolean;
    FlogRecords: TJanuaLogRecords;
    FLogRecord: TJanuaLogRecord;
    FLogDataset: TDataset;
    FOnLogMsg: TJanuaLogEvent;
    function GetLogMessage: string;
    function GetLogType: TJanuaLogType;
    function GetProcedureName: string;
    function GetFileDir: string;
    function GetOwnerName: string;
    function GetE: Exception;
    function GetRootDirectory: string;
    procedure SetComponent(const Value: TComponent);
    procedure SetE(const Value: Exception);
    procedure SetProcedureName(const Value: string);
    procedure WriteFile;
    procedure SetAutoFileName(const Value: boolean);
    procedure SetLogMessage(const Value: string);
    procedure SetResolveToFile(const Value: boolean);
    procedure SetErrorFileName(const Value: string);
    procedure SetLogFileName(const Value: string);
    procedure SetlogRecords(const Value: TJanuaLogRecords);
    procedure SetLogRecord(const Value: TJanuaLogRecord);
    procedure SetDataset(const Value: TDataset);
    procedure SetOnLogMsg(const Value: TJanuaLogEvent);
    function GetFileName: TFileName;
  public // Class functions common to any Logger in System ...........................................
    Class function GetApplicationType: TJanuaApplicationType;
    Class procedure SetApplicationType(const Value: TJanuaApplicationType);
    { Private declarations }
  protected
    { Protected declarations }
    FUpTime: TDateTime;
    FLogFileName: string;
    FErrorFileName: string;
    procedure RaiseException(ExceptionText: string);
    procedure SetIsCustomServer(const Value: boolean); virtual;
    procedure SetLogType(const Value: TJanuaLogType); virtual;
    procedure SetJanuaOS(const Value: TJanuaCoreOS); virtual;
  public
    { Public declarations }
    procedure Execute; virtual;
    property E: Exception read GetE write SetE;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property LogMessage: string read GetLogMessage write SetLogMessage;
  public
    // the method function itself + a pointer to the
    // object instance it's supposed to work on.
    procedure LogMsg(const Sender: TObject; const aLog: TJanuaLogRecord);
    procedure LogError(const Sender: TObject; const aLog: TJanuaLogRecord; E: Exception);
    property LogRecords: TJanuaLogRecords read FlogRecords write SetlogRecords;
    property LogRecord: TJanuaLogRecord read FLogRecord write SetLogRecord;
  published
    { Published declarations }
    // property JanuaOS: TJanuaCoreOS read FJanuaOS write SetJanuaOS;
    property Component: TComponent read FComponent write SetComponent;
    property LogType: TJanuaLogType read GetLogType write SetLogType;
    property FileName: TFileName read GetFileName;
    property ProcedureName: string read GetProcedureName write SetProcedureName;
    property FileDir: string read GetFileDir;
    property AutoFileName: boolean read FAutoFileName write SetAutoFileName;
    property ResolveToFile: boolean read FResolveToFile write SetResolveToFile default true;
    property RootDirectory: string read GetRootDirectory;
    property IsCustomServer: boolean read FIsCustomServer write SetIsCustomServer;
    property Uptime: TDateTime read FUpTime;
    property ErrorFileName: string read FErrorFileName write SetErrorFileName;
    property LogFileName: string read FLogFileName write SetLogFileName;
    property ApplicationType: TJanuaApplicationType read GetApplicationType write SetApplicationType
      stored false;
    property Dataset: TDataset read FLogDataset write SetDataset;
    /// New Record Logging Framework.
    property OnLogMsg: TJanuaLogEvent read FOnLogMsg write SetOnLogMsg;
    // This will hold the "closure", a pointer to
  end;

type
  TJanuaCoreLogger = class(TJanuaCustomLogger)
  private
    { Private declarations }
  protected
    { Protected declarations }
    procedure SetJanuaOS(const Value: TJanuaCoreOS); override;
    // procedure DefaulTJanuaCoreOS;
    procedure SetIsCustomServer(const Value: boolean); override;
    procedure SetLogType(const Value: TJanuaLogType); override;
  public
    { Public declarations }
  published
    { Published declarations }
  end;

type
  TJanuaObject = class(TJanuaCustomObject)
  private
    FLastMessage: string;
    FName: string;
    procedure SetVerbose(const Value: boolean);
    procedure SetActive(const Value: boolean);
    procedure SetLastMessage(const Value: string);
    procedure SetName(const Value: string);
  protected
    FActive: boolean;
    FLastErrorMessage: string;
    FHasErrors: boolean;
    FVerbose: boolean;
    procedure WriteLog(ProcedureName, LogMessage: string; isError: boolean = false); virtual;
    { gestore degli errori di classe JanuaProject }
    procedure WriteError(aProcedureName, LogMessage: string; E: Exception; doraise: boolean = true);
  public
    constructor Create; overload; virtual; // overloaded virtual Method
    constructor Create(AOwner: TJanuaCustomComponent); overload; virtual;
    constructor Create(AOwner: TJanuaCustomComponent; aName: string); overload; virtual;
    Destructor Destroy; override;
    procedure ClearErrors;
    function Activate: boolean; virtual;
    procedure Deactivate; virtual;
  published
    property LastErrorMessage: string read FLastErrorMessage stored false;
    property HasErrors: boolean read FHasErrors stored false default false;
    property Verbose: boolean read FVerbose write SetVerbose;
    property Active: boolean read FActive write SetActive stored false default false;
    property lastMessage: string read FLastMessage write SetLastMessage stored false;
    property Name: string read FName write SetName;

  end;

  TJanuaPersistent = class(TJanuaCustomPersistent)
  private
    FLastMessage: string;
    procedure SetVerbose(const Value: boolean);
    procedure SetLastMessage(const Value: string);
  protected
    FActive: boolean;
    FLastErrorMessage: string;
    FHasErrors: boolean;
    FLog: string;
    FVerbose: boolean;
    FOwner: TJanuaCustomComponent;
    procedure SetActive(const Value: boolean); override;
    procedure Deactivate; override;
    procedure AddLog(aLog: string);
    procedure SetLog(const Value: string); virtual;
    procedure WriteLog(LogMessage: string; isError: boolean = false; ProcedureName: string = ''); virtual;
    { gestore degli errori di classe JanuaProject }
    procedure WriteError(LogMessage: string; E: Exception); virtual;
    function IsDesigning: boolean;
  public
    constructor Create; overload; virtual; // overloaded virtual Method
    constructor Create(AOwner: TJanuaCustomComponent); overload; virtual;
    // overloaded virtual Method
    Destructor Destroy; override;
    function Activate: boolean; override;
    procedure ClearErrors;
    procedure ClearLog;
  published
    property Log: string read FLog write SetLog stored false;
    property LastErrorMessage: string read FLastErrorMessage stored false;
    property HasErrors: boolean read FHasErrors stored false default false;
    property Verbose: boolean read FVerbose write SetVerbose;
    property Active: boolean read FActive write SetActive stored false default false;
    property lastMessage: string read FLastMessage write SetLastMessage stored false;
  end;

var
  FGlobalTestMode: boolean;
  // variabile globale di classe FGLobalTest (permette di attivare o disattivare il test mode da
  // una class function caricata dal form o dal datamodule dove stanno i componenti.
  FComponentInstances: TList<TJanuaCustomComponent>;
  // Component Instances = TList TJanuaCustomComponent.

type
  TJanuaBindableObject = class
  {$ifdef delphixe}
  protected type
    TExpressionList = TObjectList<TBindingExpression>; // *** bindings
    // ************************************* Bindings Procedures *******************************************************
  strict protected
    FBindings: TExpressionList; // *** bindings
  protected // *** bindings
    procedure Notify(const APropertyName: string = ''); Virtual; // *** bindings
    property Bindings: TExpressionList read FBindings; // *** bindings
  public
    constructor Create; virtual;
    destructor Destroy; override;
  public
    procedure Bind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string;
      const AReadOnly: boolean = false; const ACreateOptions: TBindings.TCreateOptions = [coNotifyOutput,
      coEvaluate]);
    procedure ClearBindings;
    {$endif}
    // ************************************* Bindings Procedures *******************************************************
  end;

type
  TJanuaBindableItem = class(TCollectionItem)
  {$ifdef delphixe}
  protected type
    TExpressionList = TObjectList<TBindingExpression>; // *** bindings
    // ************************************* Bindings Procedures *********************************************
  strict protected
    FBindings: TExpressionList; // *** bindings
  protected
    /// <summary> Internal list of Bindings </summary>
    property Bindings: TExpressionList read FBindings; // *** bindings

  public
    /// <summary> Binds a local property with an Object's property
    /// and stores in FBindings the link to be released when destroyed </summary>
    procedure Bind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string;
      const AReadOnly: boolean = false; const ACreateOptions: TBindings.TCreateOptions = [coNotifyOutput,
      coEvaluate]);
    // ************************************* Bindings Procedures ***********************************
   {$endif}
    protected // *** bindings
      /// <summary> Helper to Notify changes in a property </summary>
      procedure Notify(const APropertyName: string = ''); Virtual; // *** bindings
    public
        /// <summary> overrides Create method to initialize FBindings </summary>
        constructor Create(Collection: TCollection); override;
        /// <summary> overrides Create method to destroy FBindings </summary>
        destructor Destroy; override;
        /// <summary> Clears all the bindings from Program bindings liste in FBindings </summary>
        procedure ClearBindings;
  end;

type
  TJanuaInterfacedBindableObject = class(TInterfacedObject)
   {$ifdef delphixe}
  protected type
    TExpressionList = TObjectList<TBindingExpression>; // *** bindings
    // ************************************* Bindings Procedures ***********************************
  strict protected
    FBindings: TExpressionList; // *** bindings
  protected // *** bindings
    procedure Notify(const APropertyName: string = ''); Virtual; // *** bindings
    property Bindings: TExpressionList read FBindings; // *** bindings
  public
    procedure Bind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string;
      const AReadOnly: boolean = false; const ACreateOptions: TBindings.TCreateOptions = [coNotifyOutput,
      coEvaluate]);
    procedure UnBind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string);
  {$endif}
    public
      constructor Create; overload; virtual;
      procedure ClearBindings;
      destructor Destroy; override;
    // ************************************* Bindings Procedures ***********************************
    // Log Management
  protected type
    TLocalLog = record
      DateTime: TDateTime;
      ClassName: string;
      ProcName: string;
      LogMessage: string;
    public
      function ToString: string;
      constructor Create(const aDateTime: TDateTime; const aClassName, aProcName, aLogMessage: string);
    end;
  strict private
    {$ifdef delphixe} FInternalLog: IList<TLocalLog>;{$else}  FInternalLog: TList<TLocalLog>; {$endif}
    FHasBindings: boolean;
    procedure SetHasBindings(const Value: boolean);
  strict protected
    procedure WriteLog(const aProcedureName, aLog: string);
    procedure WriteError(const aProcedureName, aLog: string; E: Exception);
    procedure WriteLocalLog(const aProcedureName, aLog: string);
    procedure ClearLocalLog(const aProcedureName: string);
    /// <summary> Is True When at least on bind is set. False if no Bind is set </summary>
    property HasBindings: boolean read FHasBindings write SetHasBindings;
  protected
    function GetLogString: string;
  public
    property LogString: string read GetLogString;
  end;

type
  TJanuaCoreComponent = class(TJanuaCustomComponent)
  public
    // ************************* Janua Global common properties ************************************
    class procedure SetGlobalTestmode(Value: boolean);
    class function GetGlobalTest: boolean;
    class function GetApplicationType: TJanuaApplicationType;
    class procedure SetApplicationType(const Value: TJanuaApplicationType);
  private
    FComponents: TObjectList<TJanuaCoreComponent>;
    // Disabilito Temporaneamnte la Gestione dei TPersistents .............................
    FPersistents: TObjectList<TJanuaPersistent>;
    FObjects: TObjectList<TJanuaObject>;
    FLogToFile: boolean;
    FHasMessage: boolean;
    FLogError: TJanuaLogRecord;
    FLocalLog: string;
    procedure SetLogToFile(const Value: boolean);
  public
    procedure ClearMessage;
  strict protected
    // virtual abstract Methods to be implemented by descendant classes .....................................
    function InternalActivate: boolean; virtual;
  {$ifdef delphixe}
   { Live Bindings Manager for the Janua Core Component ............................................................. }
  protected type
    TExpressionList = TObjectList<TBindingExpression>; // *** bindings
  // ************************************* Bindings Procedures *******************************************************
  strict protected
    FBindings: TExpressionList; // *** bindings
  // protected   // *** bindings
  procedure Notify(const APropertyName: string = ''); Virtual; // *** bindings
  property Bindings: TExpressionList read FBindings; // *** bindings
  public
    procedure Bind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string;
      const AReadOnly: boolean = false; const ACreateOptions: TBindings.TCreateOptions = [coNotifyOutput,
      coEvaluate]);
    procedure ClearBindings;
    // ************************************* Bindings Procedures *******************************************************
  {$endif  delphixe}
  private
    FIsServer: boolean;
    FDebugMode: boolean;
    procedure SetJanuaLogger(const Value: TJanuaCustomLogger);
    procedure SetIsServer(const Value: boolean);
    procedure SetDebugMode(const Value: boolean);
    function GetLogText: string;
  strict protected
    FlogRecords: TJanuaLogRecords;
    FLogErrors: TJanuaLogRecords;
    procedure SetlogRecords(const Value: TJanuaLogRecords);
  protected
    FOnChangeLanguage: TNotifyEvent;
    FLanguage: TJanuaLanguage;
    FLastMessage: string;
    FTestMode: boolean;
    procedure SetVerbose(const Value: boolean); virtual;
    procedure SetActive(const Value: boolean); virtual;
    procedure RaiseException(const sException: string);
    procedure WriteMessage(aMessage: string);
    function notDesigning: boolean;
    procedure SetTestMode(const Value: boolean); virtual;
    function isInitializing: boolean;
  protected
    FJanuaLogger: TJanuaCustomLogger;
    FVerbose: boolean;
    FActive: boolean;
    FIsLoaded: boolean;
    function GenerateJsonError(aError: string): TJsonObject;
    function GenerateJsonResult(aResult: string): TJsonObject;
    function CanRaise: boolean;
    function GetIsLoaded: boolean; virtual;
  public
    JanuaComponentCount: integer;
    constructor Create(AOwner: TComponent); override;
    Destructor Destroy; override;
    function Activate: boolean; virtual;
    function GetLocalLog: string;
    procedure AddLog(aLog: string);
    procedure Deactivate; virtual;
    procedure ClearErrors; virtual;
    procedure SetLanguage(const Value: TJanuaLanguage); virtual;
    procedure WriteLog(LogMessage: string; isError: boolean = false); overload; virtual;
    procedure WriteLog(ProcedureName, LogMessage: string; isError: boolean = false); overload; virtual;
    procedure WriteError(LogMessage: string; E: Exception; doraise: boolean = true); overload; virtual;
    procedure WriteError(ProcedureName, LogMessage: string; E: Exception; doraise: boolean = true);
      overload; virtual;
    property LogRecords: TJanuaLogRecords read FlogRecords write SetlogRecords;
  public
    property LocalLog: string read GetLocalLog;
  published
    property ApplicationType: TJanuaApplicationType read GetApplicationType write SetApplicationType
      stored false;
    property lastMessage: string read FLastMessage stored false;
    property HasMessage: boolean read FHasMessage stored false;
    property LastErrorMessage: string read FLastErrorMessage write FLastErrorMessage stored false;
    property Verbose: boolean read FVerbose write SetVerbose default true;
    property Active: boolean read FActive write SetActive stored false default false;
    property LogToFile: boolean read FLogToFile write SetLogToFile;
    property JanuaLogger: TJanuaCustomLogger read FJanuaLogger write SetJanuaLogger;
    property Language: TJanuaLanguage read FLanguage write SetLanguage;
    property OnChangeLanguage: TNotifyEvent read FOnChangeLanguage write FOnChangeLanguage;
    property IsServer: boolean read FIsServer write SetIsServer default false;
    property isLoaded: boolean read GetIsLoaded default false;
    property TestMode: boolean read FTestMode write SetTestMode;
    // property JanuaOS: TJanuaCoreOS read FJanuaOS write SetJanuaOS;
    property DebugMode: boolean read FDebugMode write SetDebugMode default false;
    property LogText: string read GetLogText;
  end;

type
  TJanuaCoreComponentSettings = class(TComponent)
  private
    FTestMode: boolean;
    procedure SetTestMode(const Value: boolean);
  published
    property TestMode: boolean read FTestMode write SetTestMode;
  end;

  {
    type
    TJanuaBindObject = class(TJanuaPersistent)
    protected type
    TExpressionList = TObjectList<TBindingExpression>;
    private
    FBindings: TExpressionList;
    protected
    procedure Notify(const APropertyName: string = '');
    property Bindings: TExpressionList read FBindings;
    public
    procedure Bind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string;
    const ACreateOptions: TBindings.TCreateOptions = [coNotifyOutput, coEvaluate]);
    procedure ClearBindings;
    public
    constructor Create; override; // override virtual Method
    Destructor Destroy; override;
    end;
  }
type
  TJanuaContent = class(TJanuaObject)
  private
  {$ifdef delphixe}
  FMemDataset: TFdMemTable;
  function geTFdMemTable: TFdMemTable;
  procedure seTFdMemTable(const Value: TFdMemTable);
  {$else}
  FMemDataset: TVirtualTable;
  function geTFdMemTable: TVirtualTable;
  procedure seTFdMemTable(const Value: TVirtualTable);
  {$endif}

  private
    FBlob: TJanuaBlob;
    FStrings: TStrings;
    FMimeType: TJanuaMime;
    FContentType: TJanuaContentType;
    FMaxLength: integer;
    FMinLength: integer;
    FDigits: smallint;
    FIsSet: boolean;
    FJsonObject: TJsonObject;
    function getAsBlob: TJanuaBlob;
    procedure setAsBlob(const Value: TJanuaBlob);
    procedure setAsString(const Value: String);
    procedure SetMimeType(const Value: TJanuaMime);
    procedure SetContentType(const Value: TJanuaContentType);
    function GetJsonObject: TJsonObject;
    procedure SetJsonObject(const Value: TJsonObject);
    procedure SetDigits(const Value: smallint);
    procedure SetMaxLength(const Value: integer);
    procedure SetMinLength(const Value: integer);
    procedure SetIsSet(const Value: boolean);
    function getAsStrings: TStrings;
    procedure setAsStrings(const Value: TStrings);
    procedure JsonObjectClear;
    procedure SetasJson(const Value: string);
    function GetAsJson: String;
    function getAsString: String;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Clear;
    procedure Unset;
    procedure LoadFromStream(aStream: TStream);
    procedure LoadFromFile(aFile: TFileName);
    // procedure LoadFromDevartDataset(aDataset: TDataset);
    procedure SaveToStream(aStream: TStream);
    procedure SaveToFile(aFile: TFileName);
    property asJson: string read GetAsJson write SetasJson;
    property AsBlob: TJanuaBlob read getAsBlob write setAsBlob;
    property AsStrings: TStrings read getAsStrings write setAsStrings;
    property AsString: String read getAsString write setAsString;
    { Creare un oggetto 'Table' che sia un Dataset ma non esattamente una Virtual Table }
    // property AsVirtualTable: TFdMemTable read geTFdMemTable write seTFdMemTable;
    property asJsonObject: TJsonObject read GetJsonObject write SetJsonObject;
  published
    property MimeType: TJanuaMime read FMimeType write SetMimeType;
    property ContentType: TJanuaContentType read FContentType write SetContentType;
    property MaxLength: integer read FMaxLength write SetMaxLength default -1;
    property MinLength: integer read FMinLength write SetMinLength default -1;
    property Digits: smallint read FDigits write SetDigits default 6;
    property isSet: boolean read FIsSet write SetIsSet;
  end;

type
  TJanuaProcedureType = (jprProcedure, jprScript, jprPage, jprStoredProcedure, jprDSSelect, jprDSInsert,
    jprDSUpdate, jprDSDelete, jprUnknown);


  // type
  // TJanuaWebMethodType = (, , , , , , , );

const
  JanuaProcedureTypeString: array [jprProcedure .. jprUnknown] of string = ('procedure', 'script', 'page',
    'storedproc', 'dsselect', 'dsinsert', 'dsupdate', 'dsdelete', 'notset');

function DecodeProcedureTypeString(aType: string): TJanuaProcedureType;

type
  TJanuaFileCache = class(TJanuaCoreComponent)
  private // components
    FTextFiles: TDictionary<String, String>;
    FFileLoader: TStrings;
  private // variables
    FFileName: string;
    FHomeDir: string;
    FSelectedFile: string;
    FFound: boolean;
  private // procedures
    procedure SetTextFiles(const Value: TDictionary<String, String>);
    procedure SetHomeDir(const Value: string);
    procedure SetSelectedFile(const Value: string);
    procedure SetFound(const Value: boolean);
  public
    property SelectedFile: String read FSelectedFile write SetSelectedFile;
    property Found: boolean read FFound write SetFound;
    function SearchFile(aDirectory, aFile: string): boolean;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property HomeDir: string read FHomeDir write SetHomeDir;
    property TextFiles: TDictionary<String, String> read FTextFiles write SetTextFiles;
  end;

type
  TJanuaCoreDialog = class(TJanuaCoreComponent)
  private
    FTitle: string;
    FText: string;
    procedure SetText(const Value: string);
    procedure SetTitle(const Value: string);
  public
    function Execute: boolean; virtual; abstract;

  published
    property Title: string read FTitle write SetTitle;
    property Text: string read FText write SetText;
  end;

  TJanuaISOCountry = class(TJanuaPersistent)
  private
    FisoCountry: TJanuaISOCountries;
    function GetCountry2Code: string;
    function GetCountry3Code: string;
    procedure SetCountry2Code(val: string);
    procedure SetCountry3Code(val: string);
    procedure SetisoCountry(const Value: TJanuaISOCountries);
  public
    constructor Create(AOwner: TJanuaCustomComponent); overload; override;
    constructor Create(AOwner: TJanuaCustomComponent; aCountry: TJanuaISOCountries); overload;
  published
    property Country3Code: string read GetCountry3Code write SetCountry3Code stored false;
    property isoCountry: TJanuaISOCountries read FisoCountry write SetisoCountry;
    property Country2Code: string read GetCountry2Code write SetCountry2Code Stored false;
  end;

type
  TJanuaISORecordLanguage = record
    ID: integer;
    Name: string;
    Code: string;
    IsoCode3: string;
    Language: TJanuaLanguage;
  end;

type
  TJanuaISOLanguages = class(TJanuaPersistent)
  private
    FJanuaISOLanguages: array of TJanuaISORecordLanguage;
    FSelectedLanguage: TJanuaISORecordLanguage;
    FFound: boolean;
    procedure SetID(const Value: integer);
    procedure SetCode(const Value: string);
    procedure SetIsoCode3(const Value: string);
    procedure SetLanguage(const Value: TJanuaLanguage);
    procedure SetLanguageName(const Value: string);
    procedure SetLanguagesList;
  public
    constructor Create(AOwner: TJanuaCustomComponent; aLanguage: TJanuaLanguage); overload;
    constructor Create(AOwner: TJanuaCustomComponent); overload; override;
    // constructor Create; overload; override; // overrides virtual Method
    function Activate: boolean; override;
    procedure Deactivate; override;
  published
    property ID: integer read FSelectedLanguage.ID write SetID;
    property LanguageName: string read FSelectedLanguage.Name write SetLanguageName;
    property Code: string read FSelectedLanguage.Code write SetCode;
    property IsoCode3: string read FSelectedLanguage.IsoCode3 write SetIsoCode3;
    property Language: TJanuaLanguage read FSelectedLanguage.Language write SetLanguage;
    property Found: boolean read FFound;

  end;

type
  TJanuaISOCulture = record
    ID: smallint;
    IsoCode3: string;
    CultureCode: string;
    LanguageName: string;
    CountryCode: TJanuaisoCountryCode;
    Country: TJanuaISOCountries;
    Culture: TJanuaCultures;
  end;

type
  TJanuaISOCultures = class(TJanuaObject)
  private
    FISOCultures: array of TJanuaISOCulture;
    FSelectedCulture: TJanuaISOCulture;
    FLanguageName: string;
    FCultureCode: string;
    FCountry: TJanuaISOCountries;
    FCountryCode: TJanuaisoCountryCode;
    FIsoCode3: string;
    FCulture: TJanuaCultures;
    FFound: boolean;
    FIsoLanguages: TJanuaISOLanguages;
    procedure SetCountry(const Value: TJanuaISOCountries);
    procedure SetCountryCode(const Value: TJanuaisoCountryCode);
    procedure SetCultureCode(const Value: string);
    procedure SetIsoCode3(const Value: string);
    procedure SetLanguageName(const Value: string);
    procedure SetCulture(const Value: TJanuaCultures);
    procedure SetSelectedCulture;
    procedure SetIsoLanguages(const Value: TJanuaISOLanguages);
  public
    Constructor Create; override;
    destructor Destroy; override;
    procedure Deactivate; override;
  published
    property IsoCode3: string read FIsoCode3 write SetIsoCode3;
    property CultureCode: string read FCultureCode write SetCultureCode;
    property LanguageName: string read FLanguageName write SetLanguageName;
    property CountryCode: TJanuaisoCountryCode read FCountryCode write SetCountryCode;
    property Culture: TJanuaCultures read FCulture write SetCulture;
    property Country: TJanuaISOCountries read FCountry write SetCountry;
    property Found: boolean read FFound;
    property IsoLanguages: TJanuaISOLanguages read FIsoLanguages write SetIsoLanguages;
  end;

  TJanuaIsoLanguageCountry = class(TJanuaCoreComponent)
  private
    FLanguageName: string;
    FMainCountry: TJanuaISOCountries;
    FCultureCode: string;
    FCultures: TJanuaISOCultures;
    FMainCountryCode: TJanuaisoCountryCode;
    FOnChangeCulture: TNotifyEvent;
    procedure SetCultureCode(const Value: string);
    procedure SetCultures(const Value: TJanuaISOCultures);
  protected
    procedure SetLanguage(const Value: TJanuaLanguage); override;
  public
    Constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property CultureCode: string read FCultureCode write SetCultureCode stored false;
    property LanguageName: string read FLanguageName stored false;
    property MainCountryCode: TJanuaisoCountryCode read FMainCountryCode stored false;
    property MainCountry: TJanuaISOCountries read FMainCountry stored false;
    property Cultures: TJanuaISOCultures read FCultures write SetCultures;
    property OnChangeCulture: TNotifyEvent read FOnChangeCulture write FOnChangeCulture;
  end;

  { TJanuaBarcode }

  TJanuaBarcode = class(TComponent)
  private
    FAutoCalc: boolean;
    FBarcode: string;
    FBarcodeType: TJanuaBarcodeType;
    FCheckDigit: string;
    FCode: string;
    FCountryCode: string;
    FFirstDigit: string;
    FisValid: boolean;
    procedure SetAutoCalc(const aValue: boolean);
    procedure SetBarcode(const aValue: string);
    procedure SetBarcodeType(const aValue: TJanuaBarcodeType);
    procedure SetFirstDigit(const aValue: string);
    procedure SetCode(const aValue: string);
    procedure SetCountryCode(const aValue: string);
    { Private declarations }
  protected
    { Protected declarations }
    function checkBarcode: boolean;
  public
    { Public declarations }
    function AddBarcode(aBarcode: string; aBarcodeType: TJanuaBarcodeType = jbtEAN13): boolean;
  published
    { Published declarations }
    property BarcodeType: TJanuaBarcodeType read FBarcodeType write SetBarcodeType;
    property AutoCalc: boolean read FAutoCalc write SetAutoCalc;
    property Code: string read FCode write SetCode;
    property Barcode: string read FBarcode write SetBarcode;
    property CheckDigit: string read FCheckDigit;
    property isValid: boolean read FisValid;
    property FirstDigit: string read FFirstDigit write SetFirstDigit;
    property CountryCode: string read FCountryCode write SetCountryCode;
  end;

type
  TJanuaIBAN = class(TJanuaCoreComponent)
  private
    { Private declarations }
  strict private
  const
    L_ABI: integer = 5;
    L_CAB: integer = 5;
    L_CONTO: integer = 12;

  var
    FIBAN: string;
    FAbi: string;
    FCab: string;
    FContoCorrente: string;
    FBBan: string;
    FCin: string;
    FCheckDigitIBAN: string;
    FisoCountry: TJanuaisoCountryCode;
    FNormalizzaCont: boolean;
    FEuroCountry: string;
    FIbanOK: boolean;
    function NormalizzaDati(codice: string; lunghezza: integer): string;
    procedure SetAbi(val: string);
    procedure SetCAb(val: string);
    procedure SetBBAN(val: string);
    procedure SetIban(val: string);
    procedure SetContoCorrente(val: string);
    function GetCheckDigitIBAN: string;
    procedure SetCheckDigitIBAN(val: string);
    function GetIsoCountry: TJanuaisoCountryCode;
    procedure SetisoCountry(val: TJanuaisoCountryCode);
    function CalculateDigits(iban: string): integer;
    function ChangeAlpha(input: string): string;
    function CheckIBAN(iban: string): boolean;
  protected
    { Protected declarations }
  public
    Procedure CheckIBANOk;
    procedure Clear;
    function Activate: boolean; override;
    { Public declarations }
  published
    property Abi: string read FAbi write SetAbi;
    property CAb: string read FCab write SetCAb;
    property iban: string read FIBAN write SetIban;
    property BBAN: string read FBBan write SetBBAN;
    property ContoCorrente: string read FContoCorrente write SetContoCorrente;
    property CheckDigitIBAN: string read GetCheckDigitIBAN write SetCheckDigitIBAN;
    property isoCountry: TJanuaisoCountryCode read GetIsoCountry write SetisoCountry;
    property Cin: string read FCin;
    property EuroCountry: string read FEuroCountry;
    Property IBanOK: boolean read FIbanOK;
    { Published declarations }
  end;

type
  TVatType = (jvtStandard, jvtIncluded);

  TJanuaVatCalculation = (jvcHiveOff, jvcAdd, jvcNone);
  // *** this specifies the kind of calculation :
  // Hive Off means that price is vat included and vat has to be hived off item
  // Add means instead that vat is not include with price and has to be addes
  // None: this operation is out of Normal VAT calculation

  TJanuaVatCode = class(TJanuaCoreComponent) { ($M+) }
  private
    FVatCode: String;
    FisoCountry: TJanuaISOCountries;
    FSpecification: string;
    FisOK: boolean;
    FError: string;
    { Private declarations }
    procedure VerifyVat; virtual;
    procedure SetisoCountry(const Value: TJanuaISOCountries);
    procedure SetVatCode(const Value: String);
    procedure SetisOK(const Value: boolean);
    procedure SetSpecification(const Value: string);
    procedure SetError(const Value: string);
  protected
    { Protected declarations }
    function InternalActivate: boolean; override;
  public
    { Public declarations }
  published
    property VatCode: String read FVatCode write SetVatCode;
    property isoCountry: TJanuaISOCountries read FisoCountry write SetisoCountry;
    property Specification: string read FSpecification write SetSpecification;
    property isOK: boolean read FisOK write SetisOK;
    property Error: string read FError write SetError;
  end;

  TJanuaFiscalCode = class(TJanuaVatCode) { ($M+) }
  private
    FBirthDate: TDateTime;
    FTownName: String;
    FFiscalCodeName: String;
    FTownCode: String;
    FFiscalCodeSurname: String;
    FFiscalCode: string;
    procedure SetBirthDate(const Value: TDateTime);
    procedure SetFiscalCodeName(const Value: String);
    procedure SetFiscalCodeSurname(const Value: String);
    procedure SetTownCode(const Value: String);
    procedure SetTownName(const Value: String);
    procedure VerifyVat; override;
    procedure SetFiscalCode(const Value: string);
    { Private declarations }
  protected
    { Protected declarations }
    function InternalActivate: boolean; override;
  public
    { Public declarations }
  published
    property FiscalCodeName: String read FFiscalCodeName write SetFiscalCodeName;
    property FiscalCodeSurname: String read FFiscalCodeSurname write SetFiscalCodeSurname;
    property BirthDate: TDateTime read FBirthDate write SetBirthDate;
    property TownName: String read FTownName write SetTownName;
    property TownCode: String read FTownCode write SetTownCode;
    property FiscalCode: string read FFiscalCode write SetFiscalCode;
  end;

type
  TJanuaVat = class(TJanuaCoreComponent)
  private
    FNetAmount: Double;
    FVatPurcent: Double;
    FGrossAmount: Double;
    FBaseAmount: Double;
    FVatType: TVatType;
    FVatAmount: Double;
    FRoundingDigits: integer;
    FVatCalculation: TJanuaVatCalculation;
    FVatHivePurcent: Single;
    procedure SetBaseAmount(const Value: Double);
    procedure SetGrossAmount(const Value: Double);
    procedure SetNetAmount(const Value: Double);
    procedure SetVatPurcent(const Value: Double);
    procedure SetVatType(const Value: TVatType);
    procedure SetVatAmount(const Value: Double);
    procedure SetRoundingDigits(const Value: integer);
    procedure SetVatCalculation(const Value: TJanuaVatCalculation);
    procedure SetVatHivePurcent(const Value: Single);
    { Private declarations }
  protected
    { Protected declarations }
    procedure CalcAmount;
    function InternalActivate: boolean; override;
  public
    { Public declarations }
  published
    { Published declarations }
    property VatPurcent: Double read FVatPurcent write SetVatPurcent;
    property VatHivePurcent: Single read FVatHivePurcent write SetVatHivePurcent;
    property VatType: TVatType read FVatType write SetVatType;
    property BaseAmount: Double read FBaseAmount write SetBaseAmount;
    property NetAmount: Double read FNetAmount write SetNetAmount;
    property GrossAmount: Double read FGrossAmount write SetGrossAmount;
    property VatAmount: Double read FVatAmount write SetVatAmount;
    property RoundingDigits: integer read FRoundingDigits write SetRoundingDigits;
    property VatCalculation: TJanuaVatCalculation read FVatCalculation write SetVatCalculation;
  end;

  { TJanuaDocument }

  TJanuaDocument = class(TComponent)
  private
    FBarcode: TJanuaBarcode;
    FDate: TDateTime;
    FDocumentID: integer;
    FFirstName: string;
    FFullName: string;
    FSecondName: string;
    procedure SetBarcode(const aValue: TJanuaBarcode);
    procedure SetDate(const aValue: TDateTime);
    procedure SetDocumentID(const aValue: integer);
    procedure SetFirstName(const aValue: string);
    procedure SetFullName(const aValue: string);
    procedure SetSecondName(const aValue: string);
    { Private declarations }
  protected
    { Protected declarations }
  public
    { Public declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    { Published declarations }
    property Date: TDateTime read FDate write SetDate;
    property FirstName: string read FFirstName write SetFirstName;
    property SecondName: string read FSecondName write SetSecondName;
    property FullName: string read FFullName write SetFullName;
    property DocumentID: integer read FDocumentID write SetDocumentID;
    property Barcode: TJanuaBarcode read FBarcode write SetBarcode;
  end;



  // --------------------- Janua Dataset -------------------------------------------------------------------

Type
  TJanuaJsonDacDataset = class(TJanuaCoreComponent)
  private
    FEncodedDataset: String;
    FDecodedDataset: TStrings;
    FJsonObject: TJsonObject;
    FKeyFields: TStrings;
    // FParams: TJanuaParams;
    FisReadOny: boolean;
    FDataSource: TDataSource;
    FIsVirtualTable: boolean;
    procedure SetDecodedDataset(const Value: TStrings);
    procedure SetEncodedDataset(const Value: string);
    procedure SetJsonObject(const Value: TJsonObject);
    procedure SetKeyFields(const Value: TStrings);
    // procedure SetParams(const Value: TJanuaParams);
    procedure SetisReadOny(const Value: boolean);
    procedure SetDataSource(const Value: TDataSource);
    procedure AssignDatasource;
    function getRecordCount: integer;
    procedure SetIsVirtualTable(const Value: boolean);
    procedure CreateVirtualTable;
  protected
    {$ifdef delphixe}
    FVirtualTable: TFdMemTable;
    procedure seTFdMemTable(const Value: TDataset);
    {$else}
    FVirtualTable: TVirtualTable;
    procedure seTFdMemTable(const Value: TDataset);
    {$endif}
  protected
    FMemDataset: TDataset;
    FPostDataset: TDataset;
    FDelDataset: TDataset;
    procedure CreateInternalDataset;
    procedure DestroyInternalDataset;
  public
    procedure LoadFromJsonObject(aObject: TJsonObject);
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function asJsonObject: TJsonObject;
    function asJson: string;
    procedure AfterPost(aDataset: TDataset);
    function FieldByName(const FieldName: string): TField;
    procedure AssignDataset(aDataset: TDataset);
  public
    procedure LoadFromFile(const FileName: string);
    procedure SaveToFile(const FileName: string);
    procedure LoadFromJson(aJson: string);
    property EncodedDataset: string read FEncodedDataset write SetEncodedDataset;
    property DecodedDataset: TStrings read FDecodedDataset write SetDecodedDataset;
    property JsonObject: TJsonObject read FJsonObject write SetJsonObject;
  public // Dataset procedures
    procedure Open;
    procedure Close;
  published
    property MemDataset: TDataset read FMemDataset write seTFdMemTable;
    property KeyFields: TStrings read FKeyFields write SetKeyFields;
    // property Params: TJanuaParams read FParams write SetParams;
    property isReadOny: boolean read FisReadOny write SetisReadOny default false;
    property DataSource: TDataSource read FDataSource write SetDataSource;
    property RecordCount: integer read getRecordCount;
    /// if set this property launches the creation of a TFdMemTable and sets the dataset to become a VTable;
    property IsVirtualTable: boolean read FIsVirtualTable write SetIsVirtualTable;
  end;

type
  TJanuaDatasetProvider = class(TJanuaCoreComponent)
  private
    FDataset: TJanuaJsonDacDataset;
    procedure SetDataset(const Value: TJanuaJsonDacDataset);
  published
    property Dataset: TJanuaJsonDacDataset read FDataset write SetDataset;
  end;

type
  TJanuaDatasetClient = class(TJanuaCoreComponent)
  private
    FDataset: TJanuaJsonDacDataset;
    procedure SetDataset(const Value: TJanuaJsonDacDataset);
  published
    property Dataset: TJanuaJsonDacDataset read FDataset write SetDataset;
  end;

{$TYPEINFO OFF}
{$METHODINFO OFF}

function DecodeGenderCode(GenderCode: string): TJanuaGenderType;
function DecodeGenderType(Gender: TJanuaGenderType): string;
function DecodeGenderIndex(GenderIndex: smallint): TJanuaGenderType;

type
  TJanuaLoginRecord = record
    Session: TJanuaServerSession;
    UserProfile: Janua.Core.Classes.TJanuaRecordUserProfile;
  private
    function GetIsLoggedIn: boolean;
    function GetIsPublicSession: boolean;
    function GetJsonObject: TJsonObject;
    procedure SetIsLoggedIn(const Value: boolean);
  public
    procedure Clear;
    procedure LoadFromJsonObject(aJsonObject: TJsonObject);
  public
    property IsPublicSession: boolean read GetIsPublicSession;
    property IsLoggedIn: boolean read GetIsLoggedIn write SetIsLoggedIn;
    property asJsonObject: TJsonObject read GetJsonObject write LoadFromJsonObject;
  end;

type
  TJanuaCustomRESTClient = class(TJanuaObject)
  private
    class function GetAppName: string;
  private
    procedure SetErrorMessage(const Value: string);
    procedure SetHasErrors(const Value: boolean);
  protected
    FUserProfile: TJanuaRecordUserProfile;
    FLoginRecord: TJanuaLoginRecord;
    FHasErrors: boolean;
    FErrorMessage: string;
    function GetIsPublic: boolean; Virtual;
    function GetIsLoggedIn: boolean; Virtual;
    procedure SetLoginRecord(const Value: TJanuaLoginRecord); Virtual;
    procedure SetUserProfile(const aUser: TJanuaRecordUserProfile); Virtual;
  public
    property IsLoggedIn: boolean read GetIsLoggedIn;
    property isPublic: boolean read GetIsPublic;
    property AppName: string read GetAppName stored false;
    property HasErrors: boolean read FHasErrors write SetHasErrors;
    property ErrorMessage: string read FErrorMessage write SetErrorMessage;
    property LoginRecord: TJanuaLoginRecord read FLoginRecord write SetLoginRecord;
    property UserProfile: TJanuaRecordUserProfile read FUserProfile write SetUserProfile;
  public
    constructor Create; override;
    destructor Destroy; override;
  public
    function Activate: boolean; override;
    procedure Deactivate; override;
    procedure LogOut; virtual;
    // definizione della classe base di client REST sicuramente una classe di metodi astratti da implementare
  end;

  TJanuaCustomRESTModel = class(TJanuaCoreComponent)
  private
    procedure SetJanuaRESTClient(const Value: TJanuaCustomRESTClient);
  protected
    FJanuaRESTClient: TJanuaCustomRESTClient;
  public
    property JanuaRESTClient: TJanuaCustomRESTClient read FJanuaRESTClient write SetJanuaRESTClient;
  end;

  TJanuaCustomViewModel = class(TJanuaCoreComponent)
  private

  protected
    RESTModel: TJanuaCustomRESTModel;
  public

  end;

procedure JwriteLog(aLog: string);

var
  FJanuaConfiguration: TJanuaConfiguration;
  FPublicRaised: boolean;

implementation

uses
{$ifdef delphixe}
  // Janua Core Libraries .........................................................................
  Spring, Delphi.Mocks.Helpers, System.DateUtils, Soap.EncdDecd, FireDAC.Comp.Dataset,
{$else}
  DateUtils,  FileUtil,
{$endif}
  Janua.Core.Functions;

procedure JwriteLog(aLog: string);
begin
  if JanuaApplicationGlobalProfile.ApplicationType = TJanuaApplicationType.jatConsoleSrv then
    Writeln(aLog);
end;

function DecodeJanuaConfType(sType: string): TJanuaConfType;
var
  i: TJanuaConfType;
begin
  Result := TJanuaConfType.jfcUnknown;

  for i := Low(TJanuaConfType) to High(TJanuaConfType) do
    if sType.ToLower = JanuaConfType[i].ToLower then
      Result := i;
end;

function DecodeProcedureTypeString(aType: string): TJanuaProcedureType;
var
  aProcedureType: TJanuaProcedureType;
begin

  Result := jprUnknown;
  for aProcedureType := jprProcedure to jprUnknown do
    if (LowerCase(JanuaProcedureTypeString[aProcedureType]) = LowerCase(aType)) then
      Result := aProcedureType;

end;

function DecodeGenderIndex(GenderIndex: smallint): TJanuaGenderType;
begin
  case GenderIndex of
    0:
      Result := TJanuaGenderType.Male;
    1:
      Result := TJanuaGenderType.Female;
  else
    Result := TJanuaGenderType.Male;
  end;
end;

function DecodeGenderCode(GenderCode: string): TJanuaGenderType;
begin
  if GenderCode = 'M' then
    Result := TJanuaGenderType.Male
  else
    Result := TJanuaGenderType.Female;
end;

function DecodeGenderType(Gender: TJanuaGenderType): string;
begin
  if Gender = TJanuaGenderType.Male then
    Result := 'M'
  else
    Result := 'F';
end;

{ TJanuaCustomRESTClient }

function TJanuaCustomRESTClient.Activate: boolean;
begin
  Result := inherited;
end;

constructor TJanuaCustomRESTClient.Create;
begin
  inherited;
end;

procedure TJanuaCustomRESTClient.Deactivate;
begin
  inherited;

end;

destructor TJanuaCustomRESTClient.Destroy;
begin
  inherited;
end;

class function TJanuaCustomRESTClient.GetAppName: string;
begin
  Result := JanuaApplicationGlobalProfile.AppName
end;

function TJanuaCustomRESTClient.GetIsLoggedIn: boolean;
begin
  Result := self.FLoginRecord.IsLoggedIn;
end;

function TJanuaCustomRESTClient.GetIsPublic: boolean;
begin
  Result := self.FLoginRecord.IsPublicSession;
end;

procedure TJanuaCustomRESTClient.LogOut;
begin
  self.FLoginRecord.Clear;
end;

procedure TJanuaCustomRESTClient.SetErrorMessage(const Value: string);
begin
  FErrorMessage := Value;
end;

procedure TJanuaCustomRESTClient.SetHasErrors(const Value: boolean);
begin
  FHasErrors := Value;
end;

procedure TJanuaCustomRESTClient.SetLoginRecord(const Value: TJanuaLoginRecord);
begin
  FLoginRecord := Value;
end;

procedure TJanuaCustomRESTClient.SetUserProfile(const aUser: TJanuaRecordUserProfile);
begin
  self.FLoginRecord.UserProfile := aUser;
end;

{ TJanuaCoreOS }

class function TJanuaCoreOS.GetActive: boolean;
begin
  Result := JanuaApplicationGlobalProfile.OSActive;
end;

class function TJanuaCoreOS.GetAppConfPath: string;
begin
  /// distinguo 3 differenti casistiche
  /// 1 - Custom Server: la directory è definita a design time e può anche non coincidere con il percorso eseguibile
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato l'eseguibile o da cui è eseguito.
  /// 3 - Tutti gli altri casi (iOS/Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user
  if not self.GetUseCurrentDir then
  begin
    Result := tpl(self.GetAppHomePath) + 'conf';
  end
  else
  begin
    Result := tpl(getCurrentPath) + 'conf';
  end;
  // self.WriteLog('AppConfPath:' + Result);
end;

class function TJanuaCoreOS.GetAppDocumentsPath: string;
begin
  /// distinguo 3 differenti casistiche
  /// 1 - Custom Server: la directory è definita a design time e può anche non coincidere con il percorso eseguibile
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato l'eseguibile o da cui è eseguito.
  /// 3 - Tutti gli altri casi (iOS/Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user

  if self.GetUseCurrentDir then
    Result := tpl(self.getCurrentPath) + 'docs'
  else if self.GetCustomServer then
    Result := tpl(self.GetAppHomePath) + 'docs'
  else
    Result := tpl(GetErgoDocumentsPath) + self.GetAppName.ToLower;

  // self.WriteLog('AppDocumentsPath:' + Result);
end;

class function TJanuaCoreOS.GetAppDownloadsPath: string;
begin
  if self.GetUseCurrentDir then
  begin
    Result := tpl(self.GetAppHomePath) + 'download';
  end
  else if self.GetCustomServer then
  begin
    Result := tpl(self.GetAppHomePath) + 'download';
  end
  else
  begin
    Result := tpl(tpl(self.GetDownloadsDirectory) + 'januaproject') + self.GetAppName.ToLower;
  end
end;

class function TJanuaCoreOS.GetAppHomePath: string;
begin
  /// distinguo 3 differenti casistiche
  /// 1 - Custom Server: la directory è definita a design time e può anche non coincidere con il percorso eseguibile
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato l'eseguibile o da cui è eseguito.
  /// 3 - Tutti gli altri casi (iOS/Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user

{$IFDEF IOS}
  Result := TPath.getDocumentsPath;
{$ELSE}
  if not self.GetUseCurrentDir then
  begin
    Result := tpl(self.GetErgoHomePath) + self.GetAppName.ToLower;
  end
  else
  begin
    Result := getCurrentPath;
  end;

{$ENDIF }
  // self.WriteLog('AppHomePath:' + Result);
end;

class function TJanuaCoreOS.GetAppLogPath: string;
begin
  /// distinguo 3 differenti casistiche
  /// 1 - Custom Server: la directory è definita a design time e può anche non coincidere con il percorso eseguibile
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato l'eseguibile o da cui è eseguito.
  /// 3 - Tutti gli altri casi (iOS/Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user

  if not self.GetUseCurrentDir then
  begin
    Result := tpl(self.GetAppHomePath) + 'log';
  end
  else
  begin
    Result := tpl(getCurrentPath) + 'log';
  end;

  // self.WriteLog('AppLogPath:' + Result);
end;

class function TJanuaCoreOS.GetAppName: string;
begin
  Result := JanuaApplicationGlobalProfile.AppName;
end;

class function TJanuaCoreOS.GetAppTempPath: string;
begin
  if self.GetCustomServer then
  begin
    Result := tpl(self.GetAppHomePath) + 'temp';
  end
  else if GetUseCurrentDir then
  begin
    Result := tpl(getCurrentPath) + 'temp';
  end
  else
  begin
    Result := tpl(self.GetErgoTempPath) + self.GetAppName.ToLower;
  end;

  // self.WriteLog('AppLogPath:' + Result);
end;

class function TJanuaCoreOS.GetCachePath: string;
begin
  {$IFDEF delphixe}   Result := TPath.GetCachePath;  {$endif}
  // self.WriteLog('CachePath =' + Result);
end;

class function TJanuaCoreOS.GetConfigFileName: string;
begin
{$IFDEF android}
  Result := IncludeTrailingPathDelimiter(GetAppConfPath) + self.GetAppName + '.json';
{$ENDIF}
{$IFDEF LINUX}
  Result := IncludeTrailingPathDelimiter(GetAppConfPath) + self.GetAppName + '.json';
{$ENDIF}
{$IFDEF MACOS}
{$IFDEF ios}
  Result := IncludeTrailingPathDelimiter(self.GetAppConfPath) + self.GetAppName + '.json';
{$ELSE}
  Result := IncludeTrailingPathDelimiter(GetAppConfPath) + self.GetAppName + '.json';
{$ENDIF}
{$ENDIF}
{$IFDEF MSWINDOWS}
  Result := IncludeTrailingPathDelimiter(GetAppConfPath) + self.GetAppName + '.json';
{$ENDIF}
end;

class function TJanuaCoreOS.GetConfiguration: string;
begin
  Result := JanuaApplicationGlobalProfile.GetConfiguration;
end;

class function TJanuaCoreOS.GetLocalComputerName: string;
begin
{$IFDEF MSWINDOWS}
  Result := self.GetComputerNameFromWindows;
{$ELSE}
  Result := '';
{$ENDIF}
end;

{$IFDEF MSWINDOWS}

class function TJanuaCoreOS.GetComputerNameFromWindows: string;
var
  iLen: Cardinal;
begin
  // try
  iLen := MAX_COMPUTERNAME_LENGTH + 1; // From Windows.pas
  Result := StringOfChar(#0, iLen);
  GetComputerName(PChar(Result), iLen);
  SetLength(Result, iLen);
  // except
  // on E: Exception do
  // self.WriteError('TJanuaCoreOS.GetComputerNameFromWindows', E);
  // end;
end;
{$ENDIF}

class function TJanuaCoreOS.getCurrentPath: string;
begin
  Result := GetCurrentDir;
end;

constructor TJanuaCoreOS.Create(AOwner: TComponent);
begin
  inherited;
end;

procedure TJanuaCoreOS.CreateConfigDataset;
begin
  {
    if not FConfigDataset.Active then
    begin
    with TStringField.Create(self) do
    begin
    Name := 'ConfigDatasetKey';
    FieldKind := fkData;
    FieldName := 'Key';
    Size := 256;
    Dataset := FConfigDataset;
    end; // FieldName
    with TStringField.Create(self) do
    begin
    Name := 'ConfigDatasetName';
    FieldKind := fkData;
    FieldName := 'Name';
    Size := 256;
    Dataset := FConfigDataset;
    end; // FieldName
    with TStringField.Create(self) do
    begin
    Name := 'ConfigDatasetType';
    FieldKind := fkData;
    FieldName := 'Type';
    Size := 12;
    Dataset := FConfigDataset;
    end; // FieldName
    with TMemoField.Create(self) do
    begin
    Name := 'ConfigDatasetValue';
    FieldKind := fkData;
    FieldName := 'Value';
    Dataset := FConfigDataset;
    end; // Last Name
    end;
    if not FConfigDataset.Active then
    FConfigDataset.Open;
    // if not FileExists(FConfigFileName) then
  }
end;

class procedure TJanuaCoreOS.Deactivate;
begin
  JanuaApplicationGlobalProfile.OSActive := false;
  if Janua.Core.Classes.FJanuaConfiguration.isLoaded then
    Janua.Core.Classes.FJanuaConfiguration.UnLoad;
end;

destructor TJanuaCoreOS.Destroy;
begin
  inherited;
end;

class procedure TJanuaCoreOS.ExternalExec(FileName, parameter: string);
var
  ThisFolder: string;
begin
  ThisFolder := self.GetAppHomePath;
  self.InternalExec(FileName, parameter);
  setcurrentdir(ThisFolder);
end;

class function TJanuaCoreOS.GetCustomServer: boolean;
begin
  Result := JanuaApplicationGlobalProfile.OsProfile.CustomServer;
end;

class function TJanuaCoreOS.GetDirectory: String;
var
  aDirectory: string;
begin
  aDirectory := JanuaApplicationGlobalProfile.OsProfile.Directory;
  Result := IfThen(aDirectory <> '', aDirectory, '.');
end;

class function TJanuaCoreOS.GetDocDirectory: string;
begin
  {$IFDEF delphixe} Result := TPath.getDocumentsPath;    {$endif}
end;

class function TJanuaCoreOS.GetDocumentDirectory: string;
begin
  {$IFDEF delphixe} Result := TPath.getDocumentsPath;   {$endif}

end;

class function TJanuaCoreOS.getDocumentsPath: string;
begin
  if self.GetCustomServer and (self.GetDirectory <> '') then
    Result := IncludeTrailingPathDelimiter(self.GetDirectory) + self.GetAppName
  else if self.GetUseCurrentDir then
    Result := tpl(self.getCurrentPath) + self.GetAppName
  {$IFDEF delphixe}
    else
    Result := tpl(TPath.getDocumentsPath) + tpl('januaproject') + tpl(self.GetAppName)
  {$endif}

end;

class function TJanuaCoreOS.GetDownloadsDirectory: string;
begin
  {$IFDEF delphixe}  Result := TPath.GetDownloadsPath;  {$endif}
end;

class function TJanuaCoreOS.GetErgoDocumentsPath: string;
begin
  /// distinguo 3 differenti casistiche
  /// 1 - Custom Server: la directory è definita a livello di descrittore
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato il controllo
  /// 3 - Tutti gli altri casi (iOS/Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user
  if self.GetCustomServer and not self.GetUseCurrentDir then
  begin
    Result := tpl(self.GetDirectory) + 'docs';
  end
  else if self.GetUseCurrentDir then
  begin
    Result := tpl(self.getCurrentPath) + 'docs';
  end
  else
  begin
    Result := IncludeTrailingPathDelimiter(self.GetDocDirectory) + 'januaproject';
  end;
end;

class function TJanuaCoreOS.GetErgoHomePath: string;
begin
  /// distinguo 4 differenti casistiche
  /// 1 - Custom Server: la directory è definita a livello di descrittore
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato il controllo
  /// 3 - Tutti gli altri casi (Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user
  /// 4 - iOS, in questo caso la scelta cade obbligatoriamente sulla Dcouments Path in quanto le altre non sono scrivibli
{$IFDEF ios}
  Result := TPath.getDocumentsPath;
{$ELSE}
  if self.GetCustomServer or self.GetUseCurrentDir then
  begin
    Result := GetHomePath
  end
  else
  begin
    Result := tpl(self.GetHomePath) + 'januaproject';
  end;

{$ENDIF}
end;

class function TJanuaCoreOS.GetErgoTempPath: string;
begin
  /// distinguo 4 differenti casistiche
  /// 1 - Custom Server: la directory è definita a livello di descrittore
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato il controllo
  /// 3 - Tutti gli altri casi (Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user
  /// 4 - iOS, in questo caso la scelta cade obbligatoriamente sulla Dcouments Path in quanto le altre non sono scrivibli
{$IFDEF ios}
  Result := tpl(TPath.getDocumentsPath) + 'temp';
{$ELSE}
  if self.GetCustomServer and not self.GetUseCurrentDir then
  begin
    Result := tpl(self.GetErgoHomePath) + 'temp'
  end
  else if self.GetUseCurrentDir then
  begin
    Result := tpl(self.getCurrentPath) + 'temp';
  end
  else
  begin
    {$IFDEF delphixe} Result := tpl(tpl(TPath.GetTempPath) + 'januaproject') + 'temp';  {$ENDIF }
  end;
{$ENDIF }
end;

class function TJanuaCoreOS.GetHomeDirectory: TJanuaOSHomeDir;
begin
  Result := JanuaApplicationGlobalProfile.OsProfile.HomeDirectory
end;

class function TJanuaCoreOS.GetHomePath: string;
begin
  /// distinguo 4 differenti casistiche
  /// 1 - Custom Server: la directory è definita a livello di descrittore
  /// 2 - Current Directory: si assume come 'home' il punto in cui è posizionato il controllo
  /// 3 - Tutti gli altri casi (Android/MacOS/Windows Desktop ad esempio) si usa la directory base sys/user
  /// 4 - iOS, in questo caso la scelta cade obbligatoriamente sulla Dcouments Path in quanto le altre non sono scrivibli
{$IFDEF ios}
  Result := TPath.getDocumentsPath;
{$ELSE}
  if self.GetCustomServer and not self.GetUseCurrentDir then
  begin
    Result := self.GetDirectory
  end
  else if self.GetUseCurrentDir then
  begin
    Result := self.getCurrentPath;
  end
  else
  begin
   {$IFDEF delphixe}  Result := TPath.GetHomePath;  {$ELSE} {$ENDIF}
  end;
{$ENDIF}
end;

class function TJanuaCoreOS.GetIsLoaded: boolean;
begin
  Result := FJanuaConfiguration.isLoaded;
end;

class function TJanuaCoreOS.GetJanuaConfiguration: TJanuaConfiguration;
begin
  Result := FJanuaConfiguration;
end;

class function TJanuaCoreOS.GetJsonConf: string;
begin
  // FilterJSON := SO(self.FJanuaConfiguration.AsJson);
  if FJanuaConfiguration.count > 0 then
    Result := FJanuaConfiguration.asJsonPretty
  else
    Result := FJanuaConfiguration.AsJsonString;
end;

class function TJanuaCoreOS.GetLibraryPath: string;
begin
  {$ifdef delphixe}
  Result := TPath.GetLibraryPath;
  {$endif}
  {$ifdef fpc}
  Result := GetUserDir;
  {$endif fpc}
end;

class function TJanuaCoreOS.GetLinuxHome: string;
begin
  Result := JanuaApplicationGlobalProfile.OsProfile.LinuxHome;
end;

class function TJanuaCoreOS.GetOsArchitecture: string;
begin
   Result := 'Unidentified';
  {$ifdef delphixe}
  case TOSVersion.Architecture of
    arIntelX86:
      Result := 'IntelX86';
    arIntelX64:
      Result := 'IntelX64';
    arARM32:
      Result := 'ARM32';
  end;
  {$endif}
  {$ifdef fpc}
  {$ifdef CPUX86_64} Result := 'IntelX64';  {$endif}
  {$ifdef CPUX86} Result := 'IntelX86';  {$endif}
  {$ifdef CPUARM} Result := 'ARM32';  {$endif}
  {$endif fpc}
end;

class function TJanuaCoreOS.GetOsMajor: string;
begin
   {$ifdef delphixe} Result := TOSVersion.Major.ToString() {$endif}
end;

class function TJanuaCoreOS.GetOsName: string;
begin
  {$ifdef delphixe} Result := TOSVersion.Name {$endif}
end;

class function TJanuaCoreOS.GetOsPlatform: string;
begin
  {$ifdef delphixe}
  Case TOSVersion.Platform of
    pfWindows:
      Result := 'Windows';
    pfMacOS:
      Result := 'MacOS';
    pfiOS:
      Result := 'iOS';
    pfAndroid:
      Result := 'Android';
    pfWinRT:
      Result := 'WinRT';
    pfLinux:
      Result := 'Linux:';
  End;
  {$endif}
  {$ifdef fpc}
  {$ifdef DARWIN} Result := 'MacOS';  {$endif}
  {$ifdef FREEBSD} Result := 'FreeBSD';  {$endif}
  {$ifdef LINUX} Result := 'Linux';  {$endif}
  {$ifdef MSWINDOWS} Result := 'Windows';  {$endif}
  {$ifdef SOLARIS} Result := 'Solaris';  {$endif}
  {$endif fpc}
end;

class function TJanuaCoreOS.GetOsString: string;
begin
  // boh? immagino sia la stringa di definizione del sistema operativo Ospite ......
  // occorre un system information
  {$ifdef delphixe} Result := TOSVersion.ToString {$endif}
end;

class function TJanuaCoreOS.GetSharedDocumentsPath: string;
begin
  {$ifdef delphixe} Result := JanuaApplicationGlobalProfile.OsProfile.SharedDocumentsPath; {$endif}
end;

class function TJanuaCoreOS.GetTempPath: string;
begin
 {$ifdef delphixe} Result := TPath.GetTempPath; {$endif}
  // self.WriteLog('FTempPath =' + Result);
end;

class function TJanuaCoreOS.GetTitle: String;
begin
  Result := JanuaApplicationGlobalProfile.OsProfile.Title;
end;

class function TJanuaCoreOS.GetUseCurrentDir: boolean;
begin
  Result := JanuaApplicationGlobalProfile.OsProfile.UseCurrentDir;
end;

class function TJanuaCoreOS.GetUserName: String;
// ****************************************************************************
// **** funzione di get current user name: rileva il nome operatore ***********
// **** loggato ora utlizzando un accesso diretto alle API di win32 ***********
// ****************************************************************************
{$IFDEF MSWINDOWS}
var
  nSize: DWord;
{$ENDIF}
begin
  Result := '';

{$IFDEF MACOS}
{$IFNDEF IOS} Result := TNSString.Wrap(NSUserName).UTF8String; {$ENDIF}
{$ENDIF}
{$IFDEF MSWINDOWS}
  nSize := 1024;
  SetLength(Result, nSize);
  if Winapi.Windows.GetUserName(PChar(Result), nSize) then
  begin
    SetLength(Result, nSize - 1)
  end
  else
  begin
    RaiseLastOSError;
  end;
  if Result = '' then
    Result := 'Administrator';
{$ENDIF}
end;

class function TJanuaCoreOS.getOSVersion: string;
begin
  {$IFDEF UNIX}
    Result := 'Unix ';
  {$ENDIF}
  {$IFDEF MSWINDOWS}
    Result := 'Windows ';
  {$ENDIF}
{$IFDEF LCLcarbon}
  Result := 'Mac OS X 10.';
{$ENDIF}
{$IFDEF Linux}
  Result := 'Linux Kernel ';
{$ENDIF}
{$IFDEF WINDOWS}
  if WindowsVersion = wv95 then
    Result := 'Windows 95 '
  else if WindowsVersion = wvNT4 then
    Result := 'Windows NT v.4 '
  else if WindowsVersion = wv98 then
    Result := 'Windows 98 '
  else if WindowsVersion = wvMe then
    Result := 'Windows ME '
  else if WindowsVersion = wv2000 then
    Result := 'Windows 2000 '
  else if WindowsVersion = wvXP then
    Result := 'Windows XP '
  else if WindowsVersion = wvServer2003 then
    Result := 'Windows Server 2003 '
  else if WindowsVersion = wvVista then
    Result := 'Windows Vista '
  else if WindowsVersion = wv7 then
    Result := 'Windows 7 '
  else
    Result := 'Windows ';
{$ENDIF}
end;

class function TJanuaCoreOS.GetResolveToFile: boolean;
begin
 Result := JanuaApplicationGlobalProfile.ResolveToFile;
end;

(*
  class function TJanuaCoreOS.getSeparator: string;
  begin
  Result := System.SysUtils.IncludeTrailingPathDelimiter
  end;
*)

class function TJanuaCoreOS.getWildCard: string;
begin
  {$ifdef delphixe} Result := TPath.PathSeparator {$endif}
  {$ifdef fpc} Result := DirectorySeparator; {$endif}
end;

class function TJanuaCoreOS.PublicActivate: boolean;
begin
  if self.GetAppName = '' then
  begin
    raise Exception.Create('Please select an unique application Name at first');
    Result := false;
  end;

  if not self.GetActive then
  begin
    SetupAppConfiguration;
    JanuaApplicationGlobalProfile.OSActive := true;
    if self.GetActive then
      self.LoadConfiguration;
  end;
  Result := GetActive;
end;

class procedure TJanuaCoreOS.InternalExec(FileName, parameter: string);
{$IFDEF FPC}
// This defines the var "AProcess" as a variable
// of the type "TProcess"
var
  AProcess: TProcess;
{$ENDIF}
begin
{$IF Defined(MSWINDOWS)}
  ShellExecute(0, 'OPEN', PChar(FileName), nil, nil, SW_SHOWNORMAL);
  // ShellExecute(0, 'OPEN', PChar(FileName), '', '', SW_SHOWNORMAL);
{$ENDIF}
{$IF Defined(MACOS)}
  // attenzione iOS non supporta (evidentemente) una chiamata alle API posix in particolare all'oggetto _system
{$IFNDEF IOS} _system(PAnsiChar('open ' + FileName)); {$ENDIF}
{$ENDIF MACOS}
{$IFDEF FPC}
  // Now we will create the TProcess object, and
  // assign it to the var AProcess.
  AProcess := TProcess.Create(nil);
  try
    // Tell the new AProcess what the command to execute is.
    // Let's use the Free Pascal compiler (i386 version that is)
    AProcess.Executable := FileName;

    // Pass -h together with ppc386 so actually 'ppc386 -h' is executed:
    if parameter <> '' then
      AProcess.Parameters.Add(parameter);

    // We will define an option for when the program
    // is run. This option will make sure that our program
    // does not continue until the program we will launch
    // has stopped running.                vvvvvvvvvvvvvv
    AProcess.Options := AProcess.Options + [poWaitOnExit];

    // Now let AProcess run the program
    AProcess.Execute;
  finally
    // This is not reached until ppc386 stops running.
    AProcess.Free;
  end;
{$ENDIF}
end;

function TJanuaCoreOS.isInitialzing: boolean;
begin
  Result := (csDesigning in ComponentState) or (csLoading in self.ComponentState) or
    (csReading in ComponentState) or (csFixups in ComponentState) or (csDestroying in ComponentState);
end;

class procedure TJanuaCoreOS.LoadConfiguration;
begin
  if self.GetActive and not FJanuaConfiguration.FIsLoaded then
  begin
    if not DirectoryExists(self.GetErgoHomePath) then
      CreateDir(GetErgoHomePath);

    if not DirectoryExists(self.GetErgoDocumentsPath) then
      CreateDir(GetErgoDocumentsPath);

    if not DirectoryExists(self.GetErgoTempPath) then
      CreateDir(GetErgoTempPath);

    if not DirectoryExists(self.GetAppHomePath) then
      CreateDir(GetAppHomePath);

    if not DirectoryExists(GetAppDocumentsPath) then
      CreateDir(self.GetAppDocumentsPath);

    if not DirectoryExists(self.GetAppLogPath) then
      CreateDir(GetAppLogPath);

    if not DirectoryExists(self.GetAppConfPath) then
      CreateDir(GetAppConfPath);

    if not DirectoryExists(self.GetAppTempPath) then
      CreateDir(GetAppTempPath);

    if (self.GetAppName > '') then
    begin
      FJanuaConfiguration.Create(GetConfigFileName);
      // self.WriteLog('Configuration Loaded: ' + GetConfigFileName);
    end;
  end;
end;

class function TJanuaCoreOS.ReadParam(Key, Name: string; Default: Double): Double;
begin
  if not FJanuaConfiguration.isLoaded then
    LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
  // WriteLog('WriteParam: ' + 'Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + Default.ToString);
end;

class function TJanuaCoreOS.ReadParam(Key, Name: string; Default: TJanuaServerRecordConfs)
  : TJanuaServerRecordConfs;
begin
  if not FJanuaConfiguration.isLoaded then
    LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
end;

class function TJanuaCoreOS.ReadDateTimeParam(Key, Name: string; Default: TDateTime): TDateTime;
begin
  if not FJanuaConfiguration.isLoaded then
    LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
  // WriteLog('WriteParam: ' + 'Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) +
  // FormatDateTime('dd-mm-yyyy hh_nn', Default));
end;

class function TJanuaCoreOS.ReadParam(Key, Name: string; Default: TJsonObject): TJsonObject;
begin
  if not FJanuaConfiguration.isLoaded then
    LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
end;

class function TJanuaCoreOS.WriteParam(Key, Name: string; Default: integer): integer;
begin
  if not FJanuaConfiguration.isLoaded then
    LoadConfiguration;
  Result := FJanuaConfiguration.setValue(Key, Name, Default);
  // WriteLog('WriteParam: ' + 'Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + Default.ToString);
end;

class function TJanuaCoreOS.WriteParam(Key, Name, Default: string): string;
begin
  if not FJanuaConfiguration.isLoaded then
    self.LoadConfiguration;
  Result := FJanuaConfiguration.setValue(Key, Name, Default);
  // WriteLog('WriteParam Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' + Default);
end;

class function TJanuaCoreOS.ReadParam(Key, Name: string; Default: integer): integer;
begin
  if not FJanuaConfiguration.isLoaded then
    self.LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
  // WriteLog('Read integer Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' + Result.ToString);
end;

{$IFDEF MSWINDOWS}

class function TJanuaCoreOS.ReadParam(Key, Name: string; Default: AnsiString): AnsiString;
begin
  if not FJanuaConfiguration.isLoaded then
    self.LoadConfiguration;
  Result := StringToAnsiString(FJanuaConfiguration.getValue(Key, Name, AnsiStringToString(Default)));
  // WriteLog('Read Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' + Result);
end;

{$ENDIF MSWINDOWS}

class function TJanuaCoreOS.ReadParam(Key, Name, Default: string): string;
begin
  if not FJanuaConfiguration.isLoaded then
    self.LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
  // WriteLog('Read Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' + Result);

end;

class procedure TJanuaCoreOS.SaveConfiguration;
begin
  if not FJanuaConfiguration.FIsLoaded then
    LoadConfiguration
  else
    FJanuaConfiguration.SaveConfiguration;
end;

function TJanuaCoreOS.Activate: boolean;
begin
  Result := not self.isInitialzing and PublicActivate
end;

class function TJanuaCoreOS.SelectFolder(var aFolder: string; const aTitle, aButtonCaption: string): boolean;
var
  LCheck: boolean;
{$IFDEF MSWINDOWS}
  procedure WinVistaSelectFolder;
  var
    FileDialog: IFileDialog;
    hr: HRESULT;
    IResult: IShellItem;
    FileName: PWideChar;
    Settings: Cardinal;
    Title: String;
  begin
    hr := CoCreateInstance(CLSID_FileOpenDialog, nil, CLSCTX_INPROC_SERVER, IFileDialog, FileDialog);
    if hr = S_OK then
    begin
      FileDialog.GetOptions(Settings);
      Settings := Settings or FOS_PICKFOLDERS or FOS_FORCEFILESYSTEM;
      FileDialog.SetOptions(Settings);
      FileDialog.SetOkButtonLabel(PWideChar(aButtonCaption));
      Title := aTitle;
      FileDialog.SetTitle(PWideChar(Title));
      hr := FileDialog.Show(0);
      if hr = S_OK then
      begin
        hr := FileDialog.GetResult(IResult);
        if hr = S_OK then
        begin
          Result := true;
          IResult.GetDisplayName(SIGDN_FILESYSPATH, FileName);
          aFolder := FileName;
        end;
      end;
    end;
  end;
{$ENDIF}
{$IFDEF MSWINDOWS}
  procedure WinXPSelectFolder;
  var
    BrowseInfo: TBrowseInfo;
    ItemIDList: PItemIDList;
    ItemSelected: PItemIDList;
    NameBuffer: array [0 .. MAX_PATH] of char;
  begin
    // Should be doing some error handling here. Omitted for clarity, but
    // obviously should raise some sort of exception if anything fails instead
    // of just returning an empty string.
    ItemIDList := nil;
    FillChar(BrowseInfo, SizeOf(BrowseInfo), 0);
    BrowseInfo.hwndOwner := 0;
    BrowseInfo.pidlRoot := ItemIDList;
    BrowseInfo.pszDisplayName := NameBuffer;
    BrowseInfo.lpszTitle := PWideChar(aTitle);
    BrowseInfo.ulFlags := BIF_RETURNONLYFSDIRS;
    ItemSelected := SHBrowseForFolder(BrowseInfo);
    if ItemSelected <> nil then
    begin
      SHGetPathFromIDList(ItemSelected, NameBuffer);
      aFolder := NameBuffer;
      Result := true;
    end;
    CoTaskMemFree(BrowseInfo.pidlRoot);
  end;
{$ENDIF}
{$IFDEF MACOS}
  procedure MacSelectDirectory(const aTitle: string; var ADir: string); //
{$IFNDEF IOS}
  var
    LOpenDir: NSOpenPanel;
    LInitialDir: NSURL;
    LDlgResult: NSInteger;
{$ENDIF}
  begin
    Result := false;
{$IFNDEF IOS}
    LOpenDir := TNSOpenPanel.Wrap(TNSOpenPanel.OCClass.openPanel);
    LOpenDir.setAllowsMultipleSelection(false);
    LOpenDir.setCanChooseFiles(false);
    LOpenDir.setCanChooseDirectories(true);
    if ADir <> '' then
    begin
      LInitialDir := TNSURL.Create;
      LInitialDir.initFileURLWithPath(NSSTR(aFolder));
      LOpenDir.setDirectoryURL(LInitialDir);
    end;
    if aTitle <> '' then
      LOpenDir.SetTitle(NSSTR(aTitle));
    LOpenDir.retain;
    try
      LDlgResult := LOpenDir.runModal;
      if LDlgResult = NSOKButton then
      begin
        aFolder := string(TNSURL.Wrap(LOpenDir.URLs.objectAtIndex(0)).relativePath.UTF8String);
        Result := true;
      end;
    finally
      LOpenDir.release;
    end;
{$ENDIF}
  end;
{$ENDIF}

begin
  Result := false;
{$IFDEF MSWINDOWS}
  if TOSVersion.Check(6) then
    WinVistaSelectFolder
  else
    WinXPSelectFolder;
{$ENDIF}
{$IFDEF MACOS}
  MacSelectDirectory(aTitle, aFolder); //
{$ENDIF}
end;

procedure TJanuaCoreOS.SetActive(const Value: boolean);
begin
  if Value and not self.isInitialzing then
    self.PublicActivate
  else
    self.Deactivate;
end;

class procedure TJanuaCoreOS.SetAppName(const Value: string);
begin
  if JanuaApplicationGlobalProfile.AppName <> Value then
  begin
    JanuaApplicationGlobalProfile.AppName := Value;
    Janua.Core.Classes.FJanuaConfiguration.UnLoad;
    self.Deactivate;
  end;
end;

{$ifdef delphixe} procedure TJanuaCoreOS.SetConfigDataset(const Value: TFdMemTable);  {$endif}
{$ifdef fpc} procedure TJanuaCoreOS.SetConfigDataset(const Value: TVirtualTable);  {$endif}
begin
  {
    if Assigned(FConfigDataset) then
    FConfigDataset.Assign(Value);
  }
end;

class procedure TJanuaCoreOS.SetCustomServer(const Value: boolean);
begin
  JanuaApplicationGlobalProfile.CustomServer := Value;
end;

class procedure TJanuaCoreOS.SetDirectory(const Value: String);
begin
  JanuaApplicationGlobalProfile.Directory := Value;
end;

class procedure TJanuaCoreOS.SetHomeDirectory(const Value: TJanuaOSHomeDir);
begin

end;

class procedure TJanuaCoreOS.SetLinuxHome(const Value: string);
begin
  JanuaApplicationGlobalProfile.LinuxHome := Value;
end;

class procedure TJanuaCoreOS.SetResolveToFile(const Value: boolean);
begin
  JanuaApplicationGlobalProfile.ResolveToFile := Value;
end;

class procedure TJanuaCoreOS.SetTitle(const Value: String);
begin
  JanuaApplicationGlobalProfile.Title := Value;
end;

class function TJanuaCoreOS.PublicWriteError(Sender: TObject; aProcedureName, sMessage: string; E: Exception;
  doraise: boolean = true): TJanuaLogRecord;
var
  ErrFile: TextFile;
  vFile: TFileName;
  LocalLog: string;
  procedure AddLog(const aLog: string);
  begin
    LocalLog := LocalLog + aLog + sLineBreak;
  end;

begin
  if Assigned(E) and not FPublicRaised then
    try
      Result.Clear;
      AddLog(DateTimeToStr(Now));
      AddLog(sMessage + ' Error:');
      // AddLog(E.Message);
      AddLog(E.ToString);
      JanuaApplicationGlobalProfile.AddLog(LocalLog);

      if JanuaApplicationGlobalProfile.IsConsole then
        Writeln(LocalLog);

      Result.DateTime := Now();
      if Sender <> nil then
      begin
        Result.ClassName := Sender.ClassName;
        Result.OwnerName := '';
        if (Sender is TComponent) and ((Sender as TComponent).Owner <> nil) then
          Result.OwnerName := IfThen((Sender as TComponent).Owner <> nil,
            (Sender as TComponent).Owner.Name, '');
      end;
      Result.ProcedureName := aProcedureName;

      if (self.GetAppName <> '') and self.GetResolveToFile then
      begin
        // ***************************************************************************
        // ******* Procedura di scrittura dello unit.testing *************************
        // ***************************************************************************
        if not DirectoryExists(self.GetHomePath) then
          CreateDir(GetHomePath);

        if not DirectoryExists(self.GetAppHomePath) then
          CreateDir(self.GetAppHomePath);

        vFile := JanuaApplicationGlobalProfile.AppName + FormatDateTime('yyyymmddhhnnss', Now()) + '.err';

        if (GetAppName > '') then
        begin
          Assignfile(ErrFile, IncludeTrailingPathDelimiter(self.GetAppLogPath) + vFile);
          If FileExists(IncludeTrailingPathDelimiter(GetAppLogPath) + vFile) then
            Append(ErrFile)
          else
            Rewrite(ErrFile);
          Writeln(ErrFile, LocalLog);
          Writeln(ErrFile, '***** Log Stack ***************');
          Writeln(ErrFile, JanuaApplicationGlobalProfile.Log);
          CloseFile(ErrFile);
        end;
      end;
      if doraise and not FPublicRaised then
      begin
        FPublicRaised := true;
        raise Exception.Create(LocalLog);
      end
      else
        FPublicRaised := false;
    except
      on E: Exception do
      begin
        FPublicRaised := true;
      end;
    end
  else
    FPublicRaised := false;
end;

class function TJanuaCoreOS.PublicWriteLog(Sender: TObject; ProcedureName, sMessage: string;
  isError: boolean = false): TJanuaLogRecord;
begin
  Result.Clear;
  if (Sender <> nil) and (Sender is TComponent) and ((Sender as TComponent).Owner <> nil) then
    Result.OwnerName := IfThen((Sender as TComponent).Owner <> nil, (Sender as TComponent).Owner.Name, '');
  Result.ProcedureName := ProcedureName;
  Result.DateTime := Now();
  Result.ClassName := Sender.ClassName;
  Result.LogMessage := sMessage;

  if JanuaApplicationGlobalProfile.ApplicationType = TJanuaApplicationType.jatConsoleSrv then
    Writeln(Result.LogText);
  JanuaApplicationGlobalProfile.AddLog(Result.LogText);
end;

class function TJanuaCoreOS.WriteParam(Key, Name: string; Default: Double): Double;
begin
  TJanuaCoreOS.LoadConfiguration;
  Result := FJanuaConfiguration.setValue(Key, Name, Default);
  // WriteLog('WriteParam: ' + 'Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + Default.ToString);
end;

class function TJanuaCoreOS.WriteParam(Key, Name: string; Default: TJanuaServerRecordConfs)
  : TJanuaServerRecordConfs;
begin
  TJanuaCoreOS.LoadConfiguration;
  Result := Default;
  FJanuaConfiguration.setValue(Key, Name, Default.AsJson);
end;

class function TJanuaCoreOS.WriteDateTimeParam(Key, Name: string; Default: TDateTime): TDateTime;
begin
  TJanuaCoreOS.LoadConfiguration;
  Result := FJanuaConfiguration.setValue(Key, Name, Default);
  // WriteLog('WriteParam: ' + 'Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) +
  // FormatDateTime('dd/mm/yyyy hh:nn', Default));
end;

class procedure TJanuaCoreOS.WriteFileText(aFileName, aMessage: string);
var
{$ifdef delphixe}  aWriter: TStreamWriter;  {$endif}
  vDirName: string;
begin
  {$ifdef delphixe}
  vDirName := IfThen(Pos('C:\', UpperCase(aFileName)) > 0, '', tpl(getDocumentsPath));
  aWriter := TStreamWriter.Create(vDirName + aFileName, true);
  try
    aWriter.WriteLine(aMessage);
  finally
    aWriter.Free;
  end;
  {$endif}
end;

class function TJanuaCoreOS.WriteParam(Key, Name: string; Default: boolean): boolean;
begin
  TJanuaCoreOS.LoadConfiguration;
  Result := FJanuaConfiguration.setValue(Key, Name, Default);
  // WriteLog('WriteParam Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' +
  // Default.ToString(true));
end;

{$IFDEF MSWINDOWS}

class function TJanuaCoreOS.WriteParam(Key, Name: string; Default: AnsiString): AnsiString;
begin
  self.LoadConfiguration;
  Result := StringToAnsiString(FJanuaConfiguration.setValue(Key, Name, unicodestring(Default)));
  // WriteLog('WriteParam Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' + Default);

end;
{$ENDIF MSWINDOWS}

class procedure TJanuaCoreOS.SetupAppConfiguration;
begin
  if (self.GetAppName = '') then
    raise Exception.Create('TJanuaCoreOS.SetupAppConfiguration AppName is Null');
  if not DirectoryExists(self.GetErgoTempPath) then
    CreateDir(self.GetErgoTempPath);
  if GetAppName > '' then
  begin
    if not DirectoryExists(self.GetAppTempPath) then
      CreateDir(self.GetAppTempPath);
  end;
  if self.GetActive then
    self.LoadConfiguration;
end;

class procedure TJanuaCoreOS.SetUseCurrentDir(const Value: boolean);
begin
  JanuaApplicationGlobalProfile.UseCurrentDir := Value;
end;

class function TJanuaCoreOS.ReadParam(Key, Name: string; Default: boolean): boolean;
begin
  self.LoadConfiguration;
  Result := FJanuaConfiguration.getValue(Key, Name, Default);
  // WriteLog('WriteParam Key = ' + QuotedStr(Key) + ' and Name = ' + QuotedStr(Name) + ', Value = ' +
  // Default.ToString(true));
end;

{ TJanuaCustomLogger }

procedure TJanuaCustomLogger.SetLogFileName(const Value: string);
begin
  FLogFileName := Value;
end;

procedure TJanuaCustomLogger.SetLogMessage(const Value: string);
begin
  self.FLogRecord.LogMessage := Value;
end;

procedure TJanuaCustomLogger.SetLogRecord(const Value: TJanuaLogRecord);
begin
  FLogRecord := Value;
end;

procedure TJanuaCustomLogger.SetlogRecords(const Value: TJanuaLogRecords);
begin
  FlogRecords := Value;
end;

procedure TJanuaCustomLogger.SetLogType(const Value: TJanuaLogType);
begin
  self.FLogRecord.LogType := Value;
end;

procedure TJanuaCustomLogger.SetOnLogMsg(const Value: TJanuaLogEvent);
begin
  FOnLogMsg := Value;
end;

procedure TJanuaCustomLogger.SetProcedureName(const Value: string);
begin
  self.FLogRecord.ProcedureName := Value;
end;

procedure TJanuaCustomLogger.SetResolveToFile(const Value: boolean);
begin
  FResolveToFile := Value;
end;

procedure TJanuaCustomLogger.WriteFile;
begin
end;

constructor TJanuaCustomLogger.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FAutoFileName := true;

  if Assigned(AOwner) then
  begin
    FComponent := AOwner;
    self.FLogRecord.OwnerName := AOwner.Name;
  end;
  self.FUpTime := Now();
  self.LogType := jltError;
  self.FResolveToFile := true;
  FErrorFileName := 'Error';
  self.FLogFileName := 'Log';
end;

destructor TJanuaCustomLogger.Destroy;
begin
  inherited;
end;

procedure TJanuaCustomLogger.Execute;
begin
  if Assigned(self.FOnLogMsg) then
    FOnLogMsg(self, self.FLogRecord);
  FText := self.FLogRecord.LogText;
end;

class function TJanuaCustomLogger.GetApplicationType: TJanuaApplicationType;
begin
  Result := JanuaApplicationGlobalProfile.ApplicationType;
end;

function TJanuaCustomLogger.GetE: Exception;
begin
  Result := nil
end;

function TJanuaCustomLogger.GetFileDir: string;
begin
  Result := '';
  // if not(csDesigning in self.ComponentState) and Assigned(self.FJanuaOS) then
  if not(csDesigning in self.ComponentState) then
    Result := TJanuaCoreOS.GetAppLogPath;

end;

function TJanuaCustomLogger.GetFileName: TFileName;
begin
  Result := '';
  if not(csDesigning in self.ComponentState) then // and Assigned(FJanuaOS) then
    Result := FormatDateTime('yyyymmddhhnnss', Now()) + TJanuaCoreOS.GetAppName;
end;

function TJanuaCustomLogger.GetLogMessage: string;
begin
  Result := self.FLogRecord.LogMessage
end;

function TJanuaCustomLogger.GetLogType: TJanuaLogType;
begin
  Result := self.FLogRecord.LogType
end;

function TJanuaCustomLogger.GetOwnerName: string;
begin
  Result := self.FLogRecord.OwnerName;
end;

function TJanuaCustomLogger.GetProcedureName: string;
begin
  Result := self.FLogRecord.ProcedureName
end;

function TJanuaCustomLogger.GetRootDirectory: string;
begin
  if not(csDesigning in self.ComponentState) then // and Assigned(FJanuaOS) then
    Result := TJanuaCoreOS.GetAppHomePath;
end;

procedure TJanuaCustomLogger.LogError(const Sender: TObject; const aLog: TJanuaLogRecord; E: Exception);
begin
  self.FLogRecord := aLog;
  if Assigned(E) then
    self.FLogRecord.LogMessage := E.Message;
  self.FLogRecord.LogType := TJanuaLogType.jltError;
  self.Execute;
end;

procedure TJanuaCustomLogger.LogMsg(const Sender: TObject; const aLog: TJanuaLogRecord);
begin
  FLogRecord := aLog;
  self.Execute;
end;

procedure TJanuaCustomLogger.RaiseException(ExceptionText: string);
begin
  self.SetLogMessage(ExceptionText);
  raise Exception.Create(ExceptionText);
end;

Class procedure TJanuaCustomLogger.SetApplicationType(const Value: TJanuaApplicationType);
begin
  JanuaApplicationGlobalProfile.ApplicationType := Value;
end;

procedure TJanuaCustomLogger.SetAutoFileName(const Value: boolean);
begin
  FAutoFileName := Value;
end;

procedure TJanuaCustomLogger.SetComponent(const Value: TComponent);
begin
  FComponent := Value;
end;

procedure TJanuaCustomLogger.SetDataset(const Value: TDataset);
begin
  FLogDataset := Value;
end;

procedure TJanuaCustomLogger.SetE(const Value: Exception);
begin
  self.FLogRecord.LogMessage := Value.Message;
end;

procedure TJanuaCustomLogger.SetErrorFileName(const Value: string);
begin
  FErrorFileName := Value;
end;

procedure TJanuaCustomLogger.SetIsCustomServer(const Value: boolean);
begin
  if Value <> self.FIsCustomServer then
  begin
    FIsCustomServer := Value;
  end;
end;

procedure TJanuaCustomLogger.SetJanuaOS(const Value: TJanuaCoreOS);
begin
  // FJanuaOS := Value;
end;

{ TJanuaDocument }

procedure TJanuaDocument.SetDate(const aValue: TDateTime);
begin
  if FDate = aValue then
    Exit;
  FDate := aValue;
end;

constructor TJanuaDocument.Create(AOwner: TComponent);
begin
  inherited;
  FBarcode := TJanuaBarcode.Create(self);
end;

destructor TJanuaDocument.Destroy;
begin
  FBarcode.Free;
  inherited;
end;

procedure TJanuaDocument.SetBarcode(const aValue: TJanuaBarcode);
begin
  if FBarcode = aValue then
    Exit;
  FBarcode := aValue;
end;

procedure TJanuaDocument.SetDocumentID(const aValue: integer);
begin
  if FDocumentID = aValue then
    Exit;
  FDocumentID := aValue;
end;

procedure TJanuaDocument.SetFirstName(const aValue: string);
begin
  if FFirstName = aValue then
    Exit;
  FFirstName := aValue;
end;

procedure TJanuaDocument.SetFullName(const aValue: string);
begin
  if FFullName = aValue then
    Exit;
  FFullName := aValue;
end;

procedure TJanuaDocument.SetSecondName(const aValue: string);
begin
  if FSecondName = aValue then
    Exit;
  FSecondName := aValue;
end;

{ TJanuaVat }

procedure TJanuaVat.CalcAmount;
begin
  if FVatType = jvtStandard then
  begin
    FGrossAmount := FRound(FBaseAmount * (100 + VatPurcent) / 100, FRoundingDigits);
    FNetAmount := FBaseAmount;
  end
  else
  begin
    FNetAmount := FRound(FBaseAmount * 100 / (100 + VatPurcent), FRoundingDigits);
    FGrossAmount := FBaseAmount;
  end;
  FVatAmount := FGrossAmount - FNetAmount;

end;

function TJanuaVat.InternalActivate: boolean;
begin
  // gestione dellaprocedura internal Activate
  self.FActive := true;
  Result := self.FActive
end;

procedure TJanuaVat.SetBaseAmount(const Value: Double);
begin
  FBaseAmount := Value;
end;

procedure TJanuaVat.SetGrossAmount(const Value: Double);
begin
  FGrossAmount := Value;
end;

procedure TJanuaVat.SetNetAmount(const Value: Double);
begin
  FNetAmount := Value;
end;

procedure TJanuaVat.SetRoundingDigits(const Value: integer);
begin
  FRoundingDigits := Value;
end;

procedure TJanuaVat.SetVatAmount(const Value: Double);
begin
  FVatAmount := Value;
end;

procedure TJanuaVat.SetVatCalculation(const Value: TJanuaVatCalculation);
begin
  FVatCalculation := Value;
end;

procedure TJanuaVat.SetVatHivePurcent(const Value: Single);
begin
  FVatHivePurcent := Value;
end;

procedure TJanuaVat.SetVatPurcent(const Value: Double);
begin
  FVatPurcent := Value;
end;

procedure TJanuaVat.SetVatType(const Value: TVatType);
begin
  FVatType := Value;
end;

{ TJanuaVatCode }

function TJanuaVatCode.InternalActivate: boolean;
begin
  Result := inherited;
end;

procedure TJanuaVatCode.SetError(const Value: string);
begin
  FError := Value;
end;

procedure TJanuaVatCode.SetisoCountry(const Value: TJanuaISOCountries);
begin
  FisoCountry := Value;
end;

procedure TJanuaVatCode.SetisOK(const Value: boolean);
begin
  FisOK := Value;
end;

procedure TJanuaVatCode.SetSpecification(const Value: string);
begin
  FSpecification := Value;
end;

procedure TJanuaVatCode.SetVatCode(const Value: String);
begin
  FVatCode := Value;
  if FisoCountry in [jicItalia] then
    VerifyVat;

end;

procedure TJanuaVatCode.VerifyVat;
var
  i: integer;
  s: integer;
  c: integer;
  r: integer;
begin
  // procedura per la verifica della partita iva ....

  // function FPartitaIva (piva: string; var Ferror: string; var Fspecification: string): boolean;
  if FisoCountry = jicItalia then
  begin
    s := 0;
    FError := '';
    FSpecification := '';

    if Length(Trim(FVatCode)) <> 11 then
    begin
      FisOK := false;
      FError := 'Attenzione inserita partita iva di lunghezza errata!';
      FSpecification := 'La partita iva italiana deve essere di 11 caratteri questa è invece di: ' +
        IntToStr(Length(Trim(FVatCode)));
    end
    else
    begin
      for i := 1 to 11 do
      begin
        if (copy(FVatCode, i, 1) < '0') or (copy(FVatCode, i, 1) > '9') then
        begin
          FError := 'La partita iva contiene caratteri non ammessi';
          FSpecification := 'la parita iva deve essere di 11 caratteri numerici';
          FisOK := false;
          Exit;
        end;

        if i / 2 = trunc(i / 2) then
        begin
          c := StrToInt(copy(FVatCode, i, 1)) * 2;
          if c > 9 then
            c := c - 9;
          s := s + c;
        end
        else if i < 11 then
          s := s + StrToInt(copy(FVatCode, i, 1));
      end;
      r := s - 10 * trunc(s / 10);
      if r = 0 then
        c := 0
      else
        c := 10 - r;

      if copy(FVatCode, 11, 1) <> IntToStr(c) then
      begin
        FError := 'La partita iva immessa non risulta compatibile';
        FSpecification := 'dalla verifica effettuata uno dei caratteri della partita iva è errato';
        FisOK := false;
        self.WriteLog(self.FError + sLineBreak + self.FSpecification, true);
      end
      else if FVatCode = '00000000000' then
      begin
        FError := 'La partita iva immessa non risulta compatibile, è composta solo da 0';
        FSpecification := 'la partita iva 00000000000 non risulta essere esistente.....';
        FisOK := false;
        self.WriteLog(self.FError + sLineBreak + self.FSpecification, true);
      end
      else
        FisOK := true;
    end;
  end;

end;

function TJanuaFiscalCode.InternalActivate: boolean;
begin
  Result := true;
  self.FActive := true;
end;

procedure TJanuaFiscalCode.SetBirthDate(const Value: TDateTime);
begin
  FBirthDate := Value;
end;

procedure TJanuaFiscalCode.SetFiscalCode(const Value: string);
begin
  FFiscalCode := Value;
  self.isOK := Janua.Core.Functions.VerifyFiscalCode(FFiscalCode, self.FError);

  if not self.FisOK then
  begin
    self.WriteMessage(self.FError);
    self.HasErrors := true;
  end;
end;

procedure TJanuaFiscalCode.SetFiscalCodeName(const Value: String);
begin
  FFiscalCodeName := Value;
end;

procedure TJanuaFiscalCode.SetFiscalCodeSurname(const Value: String);
begin
  FFiscalCodeSurname := Value;
end;

procedure TJanuaFiscalCode.SetTownCode(const Value: String);
begin
  FTownCode := Value;
end;

procedure TJanuaFiscalCode.SetTownName(const Value: String);
begin
  FTownName := Value;
end;

procedure TJanuaFiscalCode.VerifyVat;
begin
  inherited VerifyVat;

end;

procedure TJanuaBarcode.SetBarcodeType(const aValue: TJanuaBarcodeType);
begin
  if FBarcodeType = aValue then
    Exit;
  FBarcodeType := aValue;
end;

function TJanuaBarcode.AddBarcode(aBarcode: string; aBarcodeType: TJanuaBarcodeType): boolean;
var
  test: smallint;
begin
  test := Length(aBarcode);
  case test of
    7 .. 8:
      aBarcodeType := jbtEAN8;
    12 .. 13:
      aBarcodeType := jbtEAN13;
  else
    aBarcodeType := jbtOther;
  end;

  self.FBarcodeType := aBarcodeType;
  self.FBarcode := aBarcode;
  Result := self.checkBarcode;
end;

function TJanuaBarcode.checkBarcode: boolean;
var
  test: smallint;
begin
  test := Length(self.FBarcode);
  case test of
    7 .. 8:
      self.FBarcodeType := jbtEAN8;
    12 .. 13:
      self.FBarcodeType := jbtEAN13;
  else
    self.FBarcodeType := jbtOther;
  end;

  Result := CheckDigitBarcode(FBarcode, FBarcodeType);
end;

procedure TJanuaBarcode.SetAutoCalc(const aValue: boolean);
begin
  if FAutoCalc = aValue then
    Exit;
  FAutoCalc := aValue;
end;

procedure TJanuaBarcode.SetBarcode(const aValue: string);
begin
  if FBarcode = aValue then
    Exit;
  FBarcode := aValue;
end;

procedure TJanuaBarcode.SetCode(const aValue: string);
begin
  if FCode = aValue then
    Exit;
  FCode := aValue;
end;

procedure TJanuaBarcode.SetCountryCode(const aValue: string);
begin
  if FCountryCode = aValue then
    Exit;
  FCountryCode := aValue;
end;

procedure TJanuaBarcode.SetFirstDigit(const aValue: string);
begin
  if FFirstDigit = aValue then
    Exit;
  FFirstDigit := aValue;
end;

constructor TJanuaISOCountry.Create(AOwner: TJanuaCustomComponent);
begin
  inherited;
  self.FisoCountry := TJanuaISOCountries.jicNone;
end;

constructor TJanuaISOCountry.Create(AOwner: TJanuaCustomComponent; aCountry: TJanuaISOCountries);
begin
  self.Create(AOwner);
  self.FisoCountry := aCountry;
end;

function TJanuaISOCountry.GetCountry2Code: string;
begin
  Result := JanuaIsoCountry2Code[self.FisoCountry]
end;

procedure TJanuaISOCountry.SetCountry2Code(val: string);
  {$ifdef delphixe}
var
  aisoCountry: TJanuaISOCountries;
  {$else delphixe}
   function FindCountry: boolean;
   var
     I : TJanuaISOCountries;
   begin
      for I := Low(TJanuaISOCountries) to high(TJanuaISOCountries) do
       if  val = JanuaIsoCountry2Code[I] then
       begin
            FisoCountry := I;
            Result := True;
       end;
   end;
  {$endif}
begin
  if val = JanuaIsoCountry2Code[self.FisoCountry] then
    Exit;
  {$ifdef delphixe}
  if TEnumConvertor<TJanuaISOCountries>.TryFromStringArray(val, JanuaIsoCountry2Code, aisoCountry) then
    self.FisoCountry := aisoCountry
  else
  {$else}
  if not FindCountry then
  {$endif}
    FisoCountry := TJanuaISOCountries.jicNone;
end;

function TJanuaISOCountry.GetCountry3Code: string;
begin
  Result := JanuaIsoCountry3Code[self.FisoCountry]
end;

procedure TJanuaISOCountry.SetCountry3Code(val: string);
{$ifdef delphixe}
var
  aisoCountry: TJanuaISOCountries;
  {$else delphixe}
   function FindCountry: boolean;
   var
     I : TJanuaISOCountries;
   begin
      for I := Low(TJanuaISOCountries) to high(TJanuaISOCountries) do
       if  val = JanuaIsoCountry3Code[I] then
       begin
            FisoCountry := I;
            Result := True;
       end;
   end;
  {$endif}
begin
  if val = JanuaIsoCountry3Code[self.FisoCountry] then
    Exit;
  {$ifdef delphixe}
  if TEnumConvertor<TJanuaISOCountries>.TryFromStringArray(val, JanuaIsoCountry3Code, aisoCountry) then
    self.FisoCountry := aisoCountry
  else
  {$else delphixe}
  if not FindCountry then
  {$endif}
    self.FisoCountry := TJanuaISOCountries.jicNone;
end;

procedure TJanuaISOCountry.SetisoCountry(const Value: TJanuaISOCountries);
begin
  if Value = FisoCountry then
    Exit;
  FisoCountry := Value;
end;

{ TJanuaIsoLanguageCountry }

constructor TJanuaIsoLanguageCountry.Create(AOwner: TComponent);
begin
  inherited;
  FCultures := TJanuaISOCultures.Create();
end;

destructor TJanuaIsoLanguageCountry.Destroy;
begin
  self.FCultures.Free;
  inherited;
end;

procedure TJanuaIsoLanguageCountry.SetCultureCode(const Value: string);
begin
  if self.FCultureCode <> Value then
  begin
    FCultureCode := Value;
    self.FCultures.CultureCode := FCultureCode;
    self.FActive := self.FCultures.Active or self.FCultures.FIsoLanguages.Active;
    if Assigned(self.OnChangeCulture) then
      self.OnChangeCulture(self);
  end;
end;

procedure TJanuaIsoLanguageCountry.SetCultures(const Value: TJanuaISOCultures);
begin
  FCultures := Value;
end;

procedure TJanuaIsoLanguageCountry.SetLanguage(const Value: TJanuaLanguage);
var
  aComponent: TJanuaCoreComponent;
begin
  if self.FLanguage <> Value then
  begin
    FLanguage := Value;

    if Assigned(self.FCultures) then
    begin
      self.FCultures.IsoLanguages.Language := self.Language;
      self.FLanguageName := self.FCultures.IsoLanguages.LanguageName;
    end;

    if Assigned(self.FComponents) and (FComponents.count > 0) then
    begin
      for aComponent in FComponents do
      begin
        aComponent.Language := self.FLanguage;
      end;

      if Assigned(FOnChangeLanguage) then
        FOnChangeLanguage(self);

    end;

  end;

end;

procedure TJanuaIBAN.CheckIBANOk;
begin
  FIbanOK := CheckIBAN(FIBAN);
end;

procedure TJanuaIBAN.Clear;
begin
  FIbanOK := false;
  FIBAN := '';
  FAbi := '';
  FCab := '';
  FContoCorrente := '';
  FBBan := '';
  FCin := '';
  FCheckDigitIBAN := '';
  FisoCountry := jicNNN;
  FNormalizzaCont := false;
  FEuroCountry := '';
  FIbanOK := false;
end;

function TJanuaIBAN.ChangeAlpha(input: string): string;
var
  a: char;
begin
  Result := input;
  for a := 'A' to 'Z' do
  begin
    Result := StringReplace(Result, a, IntToStr(Ord(a) - 55), [rfReplaceAll]);
  end;
end;

function TJanuaIBAN.CheckIBAN(iban: string): boolean;
begin
  iban := StringReplace(iban, ' ', '', [rfReplaceAll]);
  if CalculateDigits(iban) = 1 then
    Result := true
  else
    Result := false;
end;

function TJanuaIBAN.NormalizzaDati(codice: string; lunghezza: integer): string;
begin
  codice := Trim(UpperCase(codice));
  codice := Lpad(codice, lunghezza, '0');
  Result := codice;
end;

procedure TJanuaIBAN.SetAbi(val: string);
begin
  FAbi := NormalizzaDati(val, L_ABI);
end;

procedure TJanuaIBAN.SetCAb(val: string);
begin
  FCab := NormalizzaDati(val, L_ABI);
end;

procedure TJanuaIBAN.SetIban(val: string);
begin
  FIBAN := val;
end;

procedure TJanuaIBAN.SetBBAN(val: string);
begin
  FBBan := val;
end;

procedure TJanuaIBAN.SetContoCorrente(val: string);
begin
  FContoCorrente := NormalizzaDati(val, L_CONTO);
end;

function TJanuaIBAN.GetCheckDigitIBAN: string;
begin
  Result := FCheckDigitIBAN;
end;

procedure TJanuaIBAN.SetCheckDigitIBAN(val: string);
begin
  FCheckDigitIBAN := val;
end;

function TJanuaIBAN.GetIsoCountry: TJanuaisoCountryCode;
begin
  Result := FisoCountry;
end;

procedure TJanuaIBAN.SetisoCountry(val: TJanuaisoCountryCode);
begin
  FisoCountry := val;
end;

function TJanuaIBAN.CalculateDigits(iban: string): integer;
var
  v, l: integer;
  alpha: string;
  Number: Longint;
  rest: integer;
begin
  iban := UpperCase(iban);

  if Pos('IBAN', iban) > 0 then
    delete(iban, Pos('IBAN', iban), 4);
  iban := iban + copy(iban, 1, 4);
  delete(iban, 1, 4);
  iban := ChangeAlpha(iban);

  FEuroCountry := copy(iban, 1, 2);

  if FEuroCountry = 'IT' then
  begin
    if Length(iban) >= 10 then
      FAbi := copy(iban, 6, 5);
    if Length(iban) >= 15 then
      FCab := copy(iban, 11, 5);
    if Length(iban) >= 5 then
      FCin := copy(iban, 5, 1);
    if Length(iban) >= 4 then
      FCheckDigitIBAN := copy(iban, 3, 2);
  end
  else if FEuroCountry = 'DE' then
  begin

  end;

  v := 1;
  l := 9;
  rest := 0;
  alpha := '';
  try
    while v <= Length(iban) do
    begin
      if l > Length(iban) then
        l := Length(iban);
      alpha := alpha + copy(iban, v, l);
      Number := StrToInt(alpha);
      rest := Number mod 97;
      v := v + l;
      alpha := IntToStr(rest);
      l := 9 - Length(alpha);
    end;
  except
    rest := 0;
  end;
  Result := rest;
end;

function TJanuaIBAN.Activate: boolean;
begin
  CheckIBANOk;
  Result := true;
end;

{ TJanuaCoreComponent }

function TJanuaCoreComponent.Activate: boolean;
begin
  self.ClearErrors;
  FActive := self.InternalActivate;
  Result := self.FActive;
end;

procedure TJanuaCoreComponent.AddLog(aLog: string);
begin
  self.FLocalLog := self.FLocalLog + sLineBreak + aLog;
end;


{$ifdef delphixe}
procedure TJanuaCoreComponent.Bind(const AProperty: string; const ABindToObject: TObject;
  const ABindToProperty: string; const AReadOnly: boolean; const ACreateOptions: TBindings.TCreateOptions);

  function InternalErrorMessage(aMessage: string): string;
  begin
    Result := ClassName + '.' + Name + ' Bind Error Binding ' + AProperty + ' to ' + ABindToProperty;
  end;

begin
  Guard.CheckNotNull(ABindToObject, InternalErrorMessage('ABindToObject is nil'));
  // From source to dest
  if not AReadOnly then
    FBindings.Add(TBindings.CreateManagedBinding(
      { inputs }
      [TBindings.CreateAssociationScope([Associate(self, 'src')])], 'src.' + AProperty,
      { outputs }
      [TBindings.CreateAssociationScope([Associate(ABindToObject, 'dst')])], 'dst.' + ABindToProperty, nil,
      nil, ACreateOptions));
  // From dest to source
  FBindings.Add(TBindings.CreateManagedBinding(
    { inputs }
    [TBindings.CreateAssociationScope([Associate(ABindToObject, 'src')])], 'src.' + ABindToProperty,
    { outputs }
    [TBindings.CreateAssociationScope([Associate(self, 'dst')])], 'dst.' + AProperty, nil, nil,
    ACreateOptions));
end;

procedure TJanuaCoreComponent.ClearBindings;
{ Januaproject Binding Framework .......................................................... }
var
  i: TBindingExpression;
begin
  for i in FBindings do
    TBindings.RemoveBinding(i);
  FBindings.Clear;
end;

procedure TJanuaCoreComponent.Notify(const APropertyName: string);
begin
  TBindings.Notify(self, APropertyName);
end;

{$endif delphixe}

function TJanuaCoreComponent.CanRaise: boolean;
begin
  Result := not(csDesigning in ComponentState) and not FIsServer
end;



procedure TJanuaCoreComponent.ClearErrors;
begin
  self.HasErrors := false;
  self.FLastErrorMessage := '';
end;

procedure TJanuaCoreComponent.ClearMessage;
begin
  self.FHasMessage := false;
  self.FLastMessage := '';
end;

constructor TJanuaCoreComponent.Create(AOwner: TComponent);
var
  i: integer;
begin
  inherited;
  try
    {$ifdef delphixe}
    // Live Bindings for component ..................................................
    // self.WriteLog('TJanuaCoreComponent.Create FBindings := TExpressionList.Create');
    FBindings := TExpressionList.Create(false { AOwnsObjects } ); // *** bindings
    {$endif}

    if Assigned(AOwner) and (AOwner <> nil) and (AOwner is TJanuaCoreComponent) then
    begin
      // self.ApplicationType := (AOwner as TJanuaCoreComponent).ApplicationType;
      self.Verbose := (AOwner as TJanuaCoreComponent).Verbose;
      self.JanuaLogger := (AOwner as TJanuaCoreComponent).JanuaLogger;
      self.LogToFile := (AOwner as TJanuaCoreComponent).LogToFile;
    end;

    self.WriteLog('TJanuaCoreComponent.Create ' + self.Name);
    self.FLastErrorMessage := '';
    self.HasErrors := false;
    self.FActive := false;

    FComponentInstances.Add(self);
    self.FTestMode := FGlobalTestMode;

  except
    on E: Exception do
    begin
      self.WriteError('TJanuaCoreComponent.Create', E);
    end;
  end;
end;

procedure TJanuaCoreComponent.Deactivate;
begin
  {
    for i := 0 to self.JanuaComponentCount - 1 do
    self.FJanuaComponents[i].Deactivate;
  }
  self.FActive := false;
end;

destructor TJanuaCoreComponent.Destroy;
begin
  {$ifdef delphixe}
  ClearBindings;
  FBindings.Free; // *** bindings// *** bindings
  {$endif}

  // {$IFDEF webbroker}
  FComponentInstances.Remove(self);
  // {$ENDIF}
  inherited;
end;

function TJanuaCoreComponent.isInitializing: boolean;
begin
  Result := (csLoading in ComponentState) or (csFixups in ComponentState)
end;

function TJanuaCoreComponent.notDesigning: boolean;
begin
  Result := not(csDesigning in ComponentState)
end;



procedure TJanuaCoreComponent.RaiseException(const sException: string);
begin
  if not(csDesigning in ComponentState) then
  begin
    raise Exception.Create(sException)
  end
  else
  begin
    self.WriteLog(sException);
    self.HasErrors := true;
    self.LastErrorMessage := sException;
  end;
end;

procedure TJanuaCoreComponent.SetActive(const Value: boolean);
begin
  if Value and not FActive then
  begin
    self.WriteLog('TJanuaCoreComponent.SetActive');
    FActive := self.InternalActivate;
  end
  else if not Value and FActive then
  begin
    self.Deactivate;
    self.WriteLog('TJanuaCoreComponent.Deactivate');
  end;
end;

class procedure TJanuaCoreComponent.SetApplicationType(const Value: TJanuaApplicationType);
begin
  JanuaApplicationGlobalProfile.ApplicationType := Value;
end;

procedure TJanuaCoreComponent.SetDebugMode(const Value: boolean);
begin
  FDebugMode := Value;
end;

class procedure TJanuaCoreComponent.SetGlobalTestmode(Value: boolean);
var
  i: integer;
begin
  if Value <> FGlobalTestMode then
  begin
    FGlobalTestMode := Value;
    for i := 0 to Pred(FComponentInstances.count) do
      (FComponentInstances.items[i] as TJanuaCoreComponent).FTestMode := FGlobalTestMode;
  end;
end;

procedure TJanuaCoreComponent.SetIsServer(const Value: boolean);
begin
  FIsServer := Value;
end;

procedure TJanuaCoreComponent.SetJanuaLogger(const Value: TJanuaCustomLogger);
begin
  FJanuaLogger := Value;
end;

procedure TJanuaCoreComponent.SetLanguage(const Value: TJanuaLanguage);
begin
  if self.FLanguage <> Value then
  begin
    FLanguage := Value;
    if Assigned(FOnChangeLanguage) then
      FOnChangeLanguage(self);

  end;
end;

procedure TJanuaCoreComponent.SetlogRecords(const Value: TJanuaLogRecords);
begin
  FlogRecords := Value;
end;

procedure TJanuaCoreComponent.SetLogToFile(const Value: boolean);
begin
  FLogToFile := Value;
end;

procedure TJanuaCoreComponent.SetTestMode(const Value: boolean);
begin
  FTestMode := Value;
end;

procedure TJanuaCoreComponent.SetVerbose(const Value: boolean);
begin
  self.FVerbose := Value;
end;

procedure TJanuaCoreComponent.WriteError(LogMessage: string; E: Exception; doraise: boolean = true);
begin
  if not FPublicRaised then
    self.WriteError(E.ClassName + '.' + self.Name, LogMessage, E, doraise)
  else
    FPublicRaised := false;
end;

procedure TJanuaCoreComponent.WriteLog(LogMessage: string; isError: boolean = false);
begin
  self.WriteLog('', LogMessage, isError);
end;

procedure TJanuaCoreComponent.WriteError(ProcedureName, LogMessage: string; E: Exception; doraise: boolean);
begin
  if not FPublicRaised then
    TJanuaCoreOS.PublicWriteError(self, ProcedureName, LogMessage, E, doraise);

  { end
    if not((self.FHasErrors = true) and (E.Message = '')) and not self.FPublicRaised then
    begin
    self.FLogRecord.Clear;
    if self.Owner <> nil then
    self.FLogRecord.OwnerName := self.Owner.Name;
    self.FLogRecord.ProcedureName := ProcedureName;
    self.FLogRecord.DateTime := Now();
    self.FLogRecord.ClassName := self.Name;
    self.FLogRecord.LogMessage := LogMessage;
    self.FLogRecord.E := E;
    if Assigned(self.FJanuaLogger) and not(csDesigning in ComponentState) then
    begin
    self.FJanuaLogger.LogRecord := self.FLogRecord;
    self.FJanuaLogger.Execute;
    end;
    // Delphi-Janua Bindings Framework
    Notify('Log');
    if self.FLogToFile and Assigned(self.FJanuaLogger) and not(csDesigning in ComponentState) then
    self.WriteLogToFile(LogMessage);
  }

end;

procedure TJanuaCoreComponent.WriteLog(ProcedureName, LogMessage: string; isError: boolean);
var
  aLogRecord: TJanuaLogRecord;
begin
  if not(csDesigning in self.ComponentState) then
  begin
    aLogRecord := TJanuaCoreOS.PublicWriteLog(self, ProcedureName, LogMessage, isError);
    self.AddLog(aLogRecord.LogText);
  end;
end;

procedure TJanuaCoreComponent.WriteMessage(aMessage: string);
begin
  self.FLastMessage := aMessage;
  self.FHasMessage := true;
  self.WriteLog(aMessage);
end;

{ TJanuaObject }

destructor TJanuaObject.Destroy;
begin
  inherited;
end;

function TJanuaObject.Activate: boolean;
begin
  self.ClearErrors;
  Result := self.FActive;
end;

constructor TJanuaObject.Create;
begin
  self.FLastErrorMessage := '';
end;

procedure TJanuaObject.ClearErrors;
begin
  self.FHasErrors := false;
  self.FLastErrorMessage := '';
end;

constructor TJanuaObject.Create(AOwner: TJanuaCustomComponent);
begin
  self.Create;
  if Assigned(AOwner) then
    AOwner.AddObject(self);
end;

procedure TJanuaObject.Deactivate;
begin
  self.FActive := false;
end;

procedure TJanuaObject.SetActive(const Value: boolean);
begin
  if Value and not FActive then
    FActive := self.Activate
  else
  begin
    self.FActive := Value;
    self.Deactivate;
  end;
end;

procedure TJanuaObject.SetLastMessage(const Value: string);
begin
  FLastMessage := Value;
end;

procedure TJanuaObject.SetName(const Value: string);
begin
  FName := Value;
end;

procedure TJanuaObject.SetVerbose(const Value: boolean);
begin
  self.FVerbose := Value;
end;

procedure TJanuaObject.WriteError(aProcedureName, LogMessage: string; E: Exception; doraise: boolean = true);
begin
  TJanuaCoreOS.PublicWriteError(self, aProcedureName, LogMessage, E, doraise);
end;

procedure TJanuaObject.WriteLog(ProcedureName, LogMessage: string; isError: boolean = false);
begin
  if (isError or self.FVerbose) then
  begin
    self.lastMessage := LogMessage;
    self.FHasErrors := isError;
    TJanuaCoreOS.PublicWriteLog(self, '', LogMessage, isError)
  end;
end;

{ TJanuaCorePersistent }

function TJanuaPersistent.IsDesigning: boolean;
begin
  if Assigned(FOwner) then
    Result := csDesigning in self.FOwner.ComponentState
  else
    Result := false
end;

function TJanuaPersistent.Activate: boolean;
begin
  Result := inherited;
  if Result then
  begin
    self.ClearErrors;
    Result := self.FActive;
  end;
end;

constructor TJanuaPersistent.Create;
begin
  self.FLastErrorMessage := '';
end;

procedure TJanuaPersistent.AddLog(aLog: string);
begin
  self.FLog := self.FLog + sLineBreak + aLog;
end;

procedure TJanuaPersistent.ClearErrors;
begin
  self.FHasErrors := false;
  self.ClearLog;
  self.FLastErrorMessage := '';
end;

procedure TJanuaPersistent.ClearLog;
begin
  self.FLog := '';
end;

constructor TJanuaPersistent.Create(AOwner: TJanuaCustomComponent);
begin
  if Assigned(AOwner) and (AOwner <> nil) then
  begin
    // AOwner.AddPersistent(self);
    self.FOwner := AOwner;
  end;
end;

procedure TJanuaPersistent.Deactivate;
begin
  self.ClearErrors;
  inherited;
end;

destructor TJanuaPersistent.Destroy;
begin
  // qui dovrebbe notificare il destroy
  inherited;
end;

procedure TJanuaPersistent.SetActive(const Value: boolean);
begin
  inherited;
  if Value and not FActive then
    FActive := self.Activate
  else
  begin
    self.FActive := Value;
    self.Deactivate;
  end;
end;

procedure TJanuaPersistent.SetLastMessage(const Value: string);
begin
  FLastMessage := Value;
end;

procedure TJanuaPersistent.SetLog(const Value: string);
begin
  self.FLog := Value;
end;

procedure TJanuaPersistent.SetVerbose(const Value: boolean);
begin
  self.FVerbose := Value;
end;

procedure TJanuaPersistent.WriteError(LogMessage: string; E: Exception);
begin
  if not FPublicRaised then
    TJanuaCoreOS.PublicWriteError(self, '', LogMessage, E, true);
end;

procedure TJanuaPersistent.WriteLog(LogMessage: string; isError: boolean = false; ProcedureName: string = '');
var
  aLogRecord: TJanuaLogRecord;
begin
  aLogRecord := TJanuaCoreOS.PublicWriteLog(self, ProcedureName, LogMessage, isError);
  self.AddLog(aLogRecord.LogText);
end;

constructor TJanuaObject.Create(AOwner: TJanuaCustomComponent; aName: string);
begin
  self.FName := aName;
  self.Create(AOwner);
end;

{ TJanuaBindObject }

(*
  procedure TJanuaBindObject.Bind(const AProperty: string; const ABindToObject: TObject; const ABindToProperty: string;
  const ACreateOptions: TBindings.TCreateOptions);
  begin
  // From source to dest
  FBindings.Add(TBindings.CreateManagedBinding(
  { inputs }
  [TBindings.CreateAssociationScope([Associate(self, 'src')])], 'src.' + AProperty,
  { outputs }
  [TBindings.CreateAssociationScope([Associate(ABindToObject, 'dst')])], 'dst.' + ABindToProperty, nil, nil,
  ACreateOptions));
  // From dest to source
  FBindings.Add(TBindings.CreateManagedBinding(
  { inputs }
  [TBindings.CreateAssociationScope([Associate(ABindToObject, 'src')])], 'src.' + ABindToProperty,
  { outputs }
  [TBindings.CreateAssociationScope([Associate(self, 'dst')])], 'dst.' + AProperty, nil, nil, ACreateOptions));
  end;

  procedure TJanuaBindObject.ClearBindings;
  { Januaproject Binding Framework .......................................................... }
  var
  i: TBindingExpression;
  begin
  if Assigned(FBindings) and (FBindings.count > 0) then
  for i in FBindings do
  TBindings.RemoveBinding(i);
  FBindings.Clear;
  end;

  constructor TJanuaBindObject.Create;
  begin
  inherited;
  FBindings := TExpressionList.Create(false { AOwnsObjects } );
  end;

  destructor TJanuaBindObject.Destroy;
  begin
  ClearBindings;
  if Assigned(FBindings) then
  FBindings.Free;
  inherited;
  end;

  procedure TJanuaBindObject.Notify(const APropertyName: string);
  begin
  TBindings.Notify(self, APropertyName);
  end;

*)

{ TJanuaRSSTag }

constructor TJanuaRSSTags.Create(aFeedType: TJanuaRSSFeedType);
begin
  { Title: string;
    Link: string;
    Description: string;
    Language: string;
    pubDate: string;
    lastBuildDate: string;
    generator: string; }

  self.Item.Create(aFeedType);
  Channel := 'channel';
  self.Description := 'description';
  self.Link := 'link';
  self.Image.Create(aFeedType);
  self.Language := 'language';
  self.Title := 'title';
  self.pubDate := 'pubDate';
  self.lastBuildDate := 'lastBuildDate';
  self.generator := 'generator';
  self.FeedType := aFeedType;

  case aFeedType of
    jrtWordpress:
      begin
      end;
    jrtStandard:
      begin
      end;
    jrtAIFA:
      begin
      end;
    jrtEmbarcadero:
      begin
      end;
  end;
end;

function TJanuaRSSTags.ToString: string;
begin
  Result := 'Item: ' + Item.Item + sLineBreak + 'Lang: ' + self.Language + 'Description: ' + Description +
    sLineBreak + 'Link: ' + Link + sLineBreak + 'Image: ' + Image.Url + sLineBreak + 'Date: ' + self.pubDate +
    sLineBreak + 'Title: ' + Title + sLineBreak + 'Item.Author: ' + self.Item.Author + sLineBreak;
end;

{ TJanuaFeed }

function TJanuaFeed.ToString: string;
begin
  { Title, AbstractText, LinkUrl, Text, Image, Author : unicodestring;
    Date: TDateTime; }

  Result := 'Title: ' + self.Title + sLineBreak + 'AbstractText: ' + self.AbstractText + sLineBreak +
    'LinkUrl: ' + self.LinkUrl + sLineBreak + 'Text: ' + self.Text + sLineBreak + 'Image: ' + self.Image +
    sLineBreak + 'Author: ' + self.Author + sLineBreak + 'Date: ' + DateTimeToStr(self.Date);
end;

{ TJanuaFeeds }

constructor TJanuaFeeds.Create(aFeedType: TJanuaRSSFeedType);
begin
  self.Url := '';
  self.RSSTags.Create(aFeedType);
  SetLength(self.Feeds, 0);
end;

function TJanuaFeeds.ToString: string;
var
  aFeed: TJanuaFeed;
begin
  { Url: unicodestring;
    RSSTags: TJanuaRSSTag;
    Feeds : array of TJanuaFeed; }
  Result := 'Url: ' + self.Url + sLineBreak;
  for aFeed in self.Feeds do
    Result := Result + aFeed.ToString + sLineBreak;

end;

function TJanuaCoreComponent.GenerateJsonError(aError: string): TJsonObject;
begin
  Result := TJsonObject.Create;
  JSonPair(Result, 'Result', 'False');
  JSonPair(Result, 'Message', aError);
end;

function TJanuaCoreComponent.GenerateJsonResult(aResult: string): TJsonObject;
begin
  Result := TJsonObject.Create;
  JSonPair(Result, 'Result', 'True');
  JSonPair(Result, 'Message', aResult);
end;

class function TJanuaCoreComponent.GetApplicationType: TJanuaApplicationType;
begin
  Result := JanuaApplicationGlobalProfile.ApplicationType
end;

class function TJanuaCoreComponent.GetGlobalTest: boolean;
begin
  Result := FGlobalTestMode;
end;

function TJanuaCoreComponent.GetIsLoaded: boolean;
begin
  Result := self.FIsLoaded;
end;

function TJanuaCoreComponent.GetLocalLog: string;
begin
  Result := self.FLocalLog;
end;

function TJanuaCoreComponent.GetLogText: string;
begin
  Result := self.FlogRecords.LogString
end;

function TJanuaCoreComponent.InternalActivate: boolean;
begin
  Result := FActive;
end;

{ TJanuaServerSession }

function TJanuaServerSession.getAsJsonObject: TJsonObject;
begin
  Result := TJsonObject.Create;
  Janua.Core.Functions.JsonPair(Result,'key', Key);
  Janua.Core.Functions.JsonPair(Result,'email', self.Email );
  Janua.Core.Functions.JsonPair(Result, 'session_id', self.Session_id);
  Janua.Core.Functions.JsonPair(Result, 'user_id', self.User_id);
  Janua.Core.Functions.JsonPair(Result, 'ispublic', self.isPublic);
end;

procedure TJanuaServerSession.LoadFromDataset(aDataset: TDataset);
begin
  self.Email := aDataset.FieldByName('email').AsString;
  self.Schema_id := aDataset.FieldByName('db_schema_id').AsLargeInt;
  self.Session_id := aDataset.FieldByName('db_session_id').AsLargeInt;
  self.User_id := aDataset.FieldByName('db_user_id').AsInteger;
end;

procedure TJanuaServerSession.LoadFromJsonObject(aJsonObject: TJsonObject);
begin
  SetasJsonObject(aJsonObject);
end;

procedure TJanuaServerSession.SetasJsonObject(aJsonObject: TJsonObject);
var
  aParser: TJanuaJsonParser;
begin
  if Assigned(aJsonObject) then
  begin
    self.Clear;
    aParser := TJanuaJsonParser.Create(aJsonObject);
    try
      aParser.JsonValue('key', self.FKey);
      aParser.JsonValue('email', self.Email);
      aParser.JsonValue('ispublic', self.isPublic);
      aParser.JsonValue('session_id', self.Session_id);
      aParser.JsonValue('user_id', self.User_id);
    finally
      aParser.Free;
    end;
  end;
end;

procedure TJanuaServerSession.SetKey(const Value: string);
begin
  FKey := Value;
end;

function TJanuaServerSession.asJsonPretty: string;
begin
  {$ifdef delphixe}Result := JsonPretty(self.asJsonObject.ToJSON);{$endif}
  {$ifdef fpc}Result := JsonPretty(self.asJsonObject.AsJSON);{$endif}
end;

procedure TJanuaServerSession.Clear;
begin
  self.FKey := '';
  self.Email := '';
  self.Schema_id := 0;
  self.Session_id := 0;
  self.User_id := 0;
  self.Social_ID := '';
  self.Social_Kind := '';
  SetLength(self.UserSchemas, 0);
  self.SelectedSchema.Clear;
  self.isPublic := false;
end;

function TJanuaServerSession.setSchemaByID(aID: integer): boolean;
var
  aSchema: TJanuaRecordSchema;
begin
  Result := false;
  for aSchema in self.UserSchemas do
    if aSchema.ID = aID then
    begin
      Result := true;
      self.SelectedSchema := aSchema;
      self.Schema_id := aSchema.ID;
      Exit;
    end;

end;

function TJanuaServerSession.ToString: string;
var
  aLog: TStrings;
begin
  aLog := TStringList.Create;
  try
    aLog.Add('Key: ' + FKey);
    aLog.Add(' Email' + Email);
    aLog.Add(' Schema_id:' + Schema_id.ToString());
    aLog.Add(' Session_id:' + Session_id.ToString());
    aLog.Add(' User_id:' + User_id.ToString());
    Result := aLog.Text;
  finally
    aLog.Free
  end;

end;

{ REnumerationEnumerator }

constructor REnumerationEnumerator.Create(aEnumeratorTypeInfo: PTypeInfo);
begin
  Assert(aEnumeratorTypeInfo^.Kind = tkEnumeration);
  EnumeratorTypeInfo := aEnumeratorTypeInfo;
end;

{ REnumerationEnumerator }

class function REnumerationEnumerator.From(aEnumeratorTypeInfo: PTypeInfo): REnumerationEnumerator;
begin
  Result := REnumerationEnumerator.Create(aEnumeratorTypeInfo);
end;

function REnumerationEnumerator.GetEnumerator: TEnumerationEnumerator;
begin
  Result := TEnumerationEnumerator.Create(EnumeratorTypeInfo);
end;

{ TEnumerationEnumerator }

constructor TEnumerationEnumerator.Create(aEnumeratorTypeInfo: PTypeInfo);
var
  EnumeratorTypeInfo: PTypeInfo;
  EnumerationTypeData: PTypeData;
begin
  Assert(aEnumeratorTypeInfo^.Kind = tkEnumeration);
  EnumeratorTypeInfo := aEnumeratorTypeInfo;
  EnumerationTypeData := GetTypeData(EnumeratorTypeInfo);
  FMinValue := EnumerationTypeData.MinValue;
  FMaxValue := EnumerationTypeData.MaxValue;
  FValue := FMinValue - 1;
end;

function TEnumerationEnumerator.GetCurrent: integer;
begin
  Result := FValue;
end;

function TEnumerationEnumerator.MoveNext: boolean;
begin
  Result := FValue < FMaxValue;
  if Result then
    Inc(FValue);
end;

{ TJanuaISOCultures }

constructor TJanuaISOCultures.Create;
var
  i: integer;
begin
  inherited;
  FIsoLanguages := TJanuaISOLanguages.Create;
  SetLength(self.FISOCultures, 12);

  for i := 0 to 11 do
  begin
    case i of
      0:
        begin
          FISOCultures[i].IsoCode3 := 'NNN-NNN';
          FISOCultures[i].CultureCode := 'nn-NN';
          FISOCultures[i].LanguageName := 'Not Set';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicNNN;
          FISOCultures[i].Country := TJanuaISOCountries.jicNone;
          FISOCultures[i].Culture := TJanuaCultures.jicNone_None
        end;

      1:
        begin
          FISOCultures[i].IsoCode3 := 'ITA-ITA';
          FISOCultures[i].CultureCode := 'it-IT';
          FISOCultures[i].LanguageName := 'Italiano Italia';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicITA;
          FISOCultures[i].Country := TJanuaISOCountries.jicItalia;
          FISOCultures[i].Culture := TJanuaCultures.jicItalian_Italy
        end;

      2:
        begin
          FISOCultures[i].IsoCode3 := 'ENG-GBR';
          FISOCultures[i].CultureCode := 'en-GB';
          FISOCultures[i].LanguageName := 'English Great Britain';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicGBR;
          FISOCultures[i].Country := TJanuaISOCountries.jicEngland;
          FISOCultures[i].Culture := TJanuaCultures.jicFrancais_France
        end;

      3:
        begin
          FISOCultures[i].IsoCode3 := 'ENG-USA';
          FISOCultures[i].CultureCode := 'en-US';
          FISOCultures[i].LanguageName := 'English United States';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicUSA;
          FISOCultures[i].Country := TJanuaISOCountries.jicUnitedStates;
          FISOCultures[i].Culture := TJanuaCultures.jicEnglish_USA
        end;

      4:
        begin
          FISOCultures[i].IsoCode3 := 'FRA-FRA';
          FISOCultures[i].CultureCode := 'fr-FR';
          FISOCultures[i].LanguageName := 'Français France';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicFRA;
          FISOCultures[i].Country := TJanuaISOCountries.jicFrance;
          FISOCultures[i].Culture := TJanuaCultures.jicFrancais_France
        end;

      5:
        begin
          FISOCultures[i].IsoCode3 := 'ESP-ESP';
          FISOCultures[i].CultureCode := 'es-ES';
          FISOCultures[i].LanguageName := 'Espanol Espana';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicESP;
          FISOCultures[i].Country := TJanuaISOCountries.jicEspana;
          FISOCultures[i].Culture := TJanuaCultures.jicEspanol_Espana
        end;

      6:
        begin
          FISOCultures[i].IsoCode3 := 'ESP-ARG';
          FISOCultures[i].CultureCode := 'es-AR';
          FISOCultures[i].LanguageName := 'Espanol Argentina';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicARG;
          FISOCultures[i].Country := TJanuaISOCountries.jicArgentina;
          FISOCultures[i].Culture := TJanuaCultures.jicEspanol_Espana
        end;

      7:
        begin
          FISOCultures[i].IsoCode3 := 'ESP-ARG';
          FISOCultures[i].CultureCode := 'es-AR';
          FISOCultures[i].LanguageName := 'Espanol Argentina';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicARG;
          FISOCultures[i].Country := TJanuaISOCountries.jicArgentina;
          FISOCultures[i].Culture := TJanuaCultures.jicEspanol_Espana
        end;

      8:
        begin
          FISOCultures[i].IsoCode3 := 'ESP-ARG';
          FISOCultures[i].CultureCode := 'es-AR';
          FISOCultures[i].LanguageName := 'Espanol Argentina';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicARG;
          FISOCultures[i].Country := TJanuaISOCountries.jicArgentina;
          FISOCultures[i].Culture := TJanuaCultures.jicEspanol_Espana
        end;

      9:
        begin
          FISOCultures[i].IsoCode3 := 'POR-POR';
          FISOCultures[i].CultureCode := 'pt-PT';
          FISOCultures[i].LanguageName := 'Portugues Portugal';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicPOR;
          FISOCultures[i].Country := TJanuaISOCountries.jicPortugal;
          FISOCultures[i].Culture := TJanuaCultures.jicPortugues_Portugal
        end;

      10:
        begin
          FISOCultures[i].IsoCode3 := 'POR-BRA';
          FISOCultures[i].CultureCode := 'pt-BR';
          FISOCultures[i].LanguageName := 'Portugues Brazil';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicBRA;
          FISOCultures[i].Country := TJanuaISOCountries.jicBrazil;
          FISOCultures[i].Culture := TJanuaCultures.jicPortugues_Brazil
        end;

      11:
        begin
          FISOCultures[i].IsoCode3 := 'DEU-DEU';
          FISOCultures[i].CultureCode := 'de-DE';
          FISOCultures[i].LanguageName := 'Deutsch Deutschland';
          FISOCultures[i].CountryCode := TJanuaisoCountryCode.jicDEU;
          FISOCultures[i].Country := TJanuaISOCountries.jicDeutschland;
          FISOCultures[i].Culture := TJanuaCultures.jicDeutsch_Deutschland
        end;

    end;

  end;

  self.SetCulture(TJanuaCultures.jicNone_None);
end;

procedure TJanuaISOCultures.Deactivate;
begin
  inherited;
  SetCulture(TJanuaCultures.jicNone_None);

end;

destructor TJanuaISOCultures.Destroy;
begin
  self.FIsoLanguages.Free;
  inherited;
end;

procedure TJanuaISOCultures.SetCountry(const Value: TJanuaISOCountries);
begin
  FCountry := Value;
end;

procedure TJanuaISOCultures.SetCountryCode(const Value: TJanuaisoCountryCode);
begin
  FCountryCode := Value;
end;

procedure TJanuaISOCultures.SetCulture(const Value: TJanuaCultures);
var
  aCulture: TJanuaISOCulture;
begin
  if Value <> FCulture then
  begin
    FFound := false;
    FCulture := Value;
    for aCulture in self.FISOCultures do
    begin
      if aCulture.Culture = FCulture then
      begin
        self.FSelectedCulture := aCulture;
        FFound := true;
        SetSelectedCulture;
        Exit;
      end;
    end;
    if not FFound then
      self.Deactivate;

  end;
end;

procedure TJanuaISOCultures.SetCultureCode(const Value: string);
var
  aCulture: TJanuaISOCulture;
  sCultureCode: String;
  aChar: WideChar;
begin
  FFound := true;
  if Length(Value) > 5 then
    sCultureCode := copy(Value, 1, 5);

  if sCultureCode <> FCultureCode then
  begin
    self.WriteLog('TJanuaISOCultures.SetCultureCode', 'Searching Culture Code: ' + Value);
    FFound := false;
    FCultureCode := sCultureCode;
    if Length(self.FCultureCode) = 5 then
    begin
      for aCulture in self.FISOCultures do
      begin
        if UpperCase(aCulture.CultureCode) = UpperCase(FCultureCode) then
        begin
          self.FSelectedCulture := aCulture;
          self.WriteLog('TJanuaISOCultures.SetCultureCode',
            'Found Culture: ' + FSelectedCulture.LanguageName);
          FFound := true;
          SetSelectedCulture;
          self.FIsoLanguages.Code := copy(Value, 1, 2);
          Exit;
        end;
      end;
      if not FFound then
      begin
        self.WriteLog('TJanuaISOCultures.SetCultureCode', 'Not Found Culture: ' + Value);
        self.SetCulture(TJanuaCultures.jicNone_None);
        FIsoLanguages.Code := copy(sCultureCode, 1, 2);
      end;
    end
    else
    begin
      self.FIsoLanguages.Code := Value;
      self.SetCulture(TJanuaCultures.jicNone_None);
      self.FFound := not(FIsoLanguages.Language = TJanuaLanguage.jlaNone);
      if self.FFound then
        self.Activate;
      self.FCultureCode := Value;
    end;

  end;

end;

procedure TJanuaISOCultures.SetIsoCode3(const Value: string);
begin
  FIsoCode3 := Value;
end;

procedure TJanuaISOCultures.SetIsoLanguages(const Value: TJanuaISOLanguages);
begin
  FIsoLanguages := Value;
end;

procedure TJanuaISOCultures.SetLanguageName(const Value: string);
begin
  FLanguageName := Value;
end;

procedure TJanuaISOCultures.SetSelectedCulture;
begin
  FLanguageName := FSelectedCulture.LanguageName;
  FCultureCode := FSelectedCulture.CultureCode;
  FCountry := FSelectedCulture.Country;
  FCountryCode := FSelectedCulture.CountryCode;
  FIsoCode3 := FSelectedCulture.IsoCode3;
  FCulture := FSelectedCulture.Culture;
  self.FActive := not(FSelectedCulture.Culture = jicNone_None);
end;

constructor TJanuaISOLanguages.Create(AOwner: TJanuaCustomComponent; aLanguage: TJanuaLanguage);
begin
  self.Create(AOwner);
  self.SetLanguage(aLanguage);
end;

procedure TJanuaISOLanguages.Deactivate;
begin
  self.FSelectedLanguage := FJanuaISOLanguages[0];
end;

function TJanuaISOLanguages.Activate: boolean;
begin
  Result := inherited;
  Result := self.FSelectedLanguage.Language <> TJanuaLanguage.jlaNone;
  self.FActive := Result;
end;

procedure TJanuaISOLanguages.SetCode(const Value: string);
var
  aLanguage: TJanuaISORecordLanguage;
begin
  if FSelectedLanguage.Code <> FSelectedLanguage.Code then
  begin
    self.FFound := false;
    for aLanguage in FJanuaISOLanguages do
    begin
      if aLanguage.Code = Value then
      begin
        self.FSelectedLanguage := aLanguage;
        self.Activate;
        self.FFound := true;
        Exit;
      end;
    end;
    if not self.FFound then
      self.Deactivate;

  end;
end;

procedure TJanuaISOLanguages.SetID(const Value: integer);
var
  aLanguage: TJanuaISORecordLanguage;
begin
  if FSelectedLanguage.ID <> Value then
  begin
    for aLanguage in FJanuaISOLanguages do
    begin
      if aLanguage.ID = Value then
      begin
        self.FSelectedLanguage := aLanguage;
        self.Activate;
        Exit;
      end;
    end;
  end;
end;

procedure TJanuaISOLanguages.SetIsoCode3(const Value: string);
var
  aLanguage: TJanuaISORecordLanguage;
begin
  if FSelectedLanguage.IsoCode3 <> Value then
  begin
    for aLanguage in FJanuaISOLanguages do
    begin
      if aLanguage.IsoCode3 = Value then
      begin
        self.FSelectedLanguage := aLanguage;
        self.Activate;
        Exit;
      end;
    end;
  end;
end;

procedure TJanuaISOLanguages.SetLanguage(const Value: TJanuaLanguage);
var
  aLanguage: TJanuaISORecordLanguage;
begin
  if FSelectedLanguage.Language <> Value then
  begin
    for aLanguage in FJanuaISOLanguages do
    begin
      if aLanguage.Language = Value then
      begin
        self.FSelectedLanguage := aLanguage;
        self.Activate;
        Exit;
      end;
    end;
  end;
end;

procedure TJanuaISOLanguages.SetLanguageName(const Value: string);
var
  aLanguage: TJanuaISORecordLanguage;
begin
  if FSelectedLanguage.Name <> Value then
  begin
    FFound := false;
    for aLanguage in FJanuaISOLanguages do
    begin
      if aLanguage.Name = Value then
      begin
        self.FSelectedLanguage := aLanguage;
        self.Activate;
        FFound := true;
        Exit;
      end;
    end;
    if not self.FFound then
    begin
      self.Deactivate;
    end;
  end;
end;

procedure TJanuaISOLanguages.SetLanguagesList;
var
  i: integer;
begin
  SetLength(self.FJanuaISOLanguages, 7);
  for i := 0 to 6 do
  begin
    case i of
      0:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'None';
          FJanuaISOLanguages[i].Code := 'nn';
          FJanuaISOLanguages[i].IsoCode3 := 'nnn';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaNone;
        end;
      1:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'Italiano';
          FJanuaISOLanguages[i].Code := 'it';
          FJanuaISOLanguages[i].IsoCode3 := 'ita';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaItalian;
        end;
      2:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'English';
          FJanuaISOLanguages[i].Code := 'en';
          FJanuaISOLanguages[i].IsoCode3 := 'eng';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaEnglish;
        end;
      3:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'Français';
          FJanuaISOLanguages[i].Code := 'fr';
          FJanuaISOLanguages[i].IsoCode3 := 'fra';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaFrancais;
        end;
      4:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'Espanol';
          FJanuaISOLanguages[i].Code := 'es';
          FJanuaISOLanguages[i].IsoCode3 := 'esp';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaEspanol;
        end;
      5:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'Russkij';
          FJanuaISOLanguages[i].Code := 'ru';
          FJanuaISOLanguages[i].IsoCode3 := 'rus';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaRussian;
        end;
      6:
        begin
          FJanuaISOLanguages[i].ID := i;
          FJanuaISOLanguages[i].Name := 'Deutsch';
          FJanuaISOLanguages[i].Code := 'de';
          FJanuaISOLanguages[i].IsoCode3 := 'deu';
          FJanuaISOLanguages[i].Language := TJanuaLanguage.jlaGerman;
        end;
    end;
  end;
  self.SetLanguage(TJanuaLanguage.jlaNone);
end;

constructor TJanuaISOLanguages.Create(AOwner: TJanuaCustomComponent);
begin
  inherited Create(AOwner);
  self.SetLanguagesList;
end;

{ TJanuaDisclaimer }

function TJanuaDisclaimer.asJsonObject: TJsonObject;
var
  a: TJsonObject;
begin
  a := TJsonObject.Create;
  JSonPair(a,'Terms', self.Terms);
  JSonPair(a,'About', self.About);
  JSonPair(a,'Privacy', self.Privacy);
  Result := a;
end;

procedure TJanuaDisclaimer.LoadFromDataset(aDataset: TDataset);
begin
  self.Terms := aDataset.FieldByName('terms').AsString;
  self.About := aDataset.FieldByName('about').AsString;
  self.Privacy := aDataset.FieldByName('privacy').AsString;
end;

function TJanuaDisclaimer.SaveToDataset(aDataset: TDataset): boolean;
begin
  aDataset.Edit;
  self.Terms := aDataset.FieldByName('terms').AsString;
  self.About := aDataset.FieldByName('about').AsString;
  self.Privacy := aDataset.FieldByName('privacy').AsString;
  Result := true;
end;

{ TJanuaMime }

procedure TJanuaMime.Assign(Source: TPersistent);
var
  m: TJanuaMime;
begin
  if (Source is TJanuaMime) then
  begin
    m := (Source as TJanuaMime);
    self.FCharset := m.Charset;
    self.MimeType := m.MimeType;
    self.FExtension := m.Extension;
    self.FMimeList.Assign(m.MimeList);
    self.FCharSetList.Assign(m.CharSetList);
  end
  else
    inherited;
end;

constructor TJanuaMime.Create;
var
  a: TJanuaMimeType;
begin
  FMimeList := TStringList.Create;
  FCharSetList := TStringList.Create;
  for a in [TJanuaMimeType.jmtApplicationJson .. TJanuaMimeType.jmtUnknown] do
    self.FMimeList.Add(JanuaMimeString[a])
end;

destructor TJanuaMime.Destroy;
begin
  self.FCharSetList.Free;
  self.FMimeList.Free;
  inherited;
end;

function TJanuaMime.getCharsetString: string;
begin
  Result := JanuaCharsetString[self.FCharset];
end;

function TJanuaMime.getIsSet: boolean;
begin
  Result := self.FMimeType <> jmtUnknown;
end;

function TJanuaMime.getMimeString: string;
begin
  Result := JanuaMimeString[self.FMimeType];
end;

procedure TJanuaMime.SetCharset(const Value: TJanuaCharsetType);
begin
  FCharset := Value;
end;

procedure TJanuaMime.SetCharSetList(const Value: TStrings);
begin
  FCharSetList := Value;
end;

procedure TJanuaMime.SetCharsetString(const Value: string);
var
  a: TJanuaCharsetType;
begin
  // Appena Ricevo un Encoding setto il type.
  self.FCharset := TJanuaCharsetType.jcsUnknown;
  if Value <> '' then
    for a := TJanuaCharsetType.jcsUnknown to TJanuaCharsetType.jcsISO8859_1 do
      if JanuaCharsetString[a] = Value then
        self.FCharset := a;
end;

procedure TJanuaMime.SetExtension(const Value: string);
begin
  FExtension := Value;
end;

procedure TJanuaMime.SetMimeList(const Value: TStrings);
begin
  FMimeList := Value;
end;

procedure TJanuaMime.SetMimeString(const Value: string);
var
  a: TJanuaMimeType;
begin
  self.FMimeType := TJanuaMimeType.jmtUnknown;
  if Value <> '' then
    for a in [jmtApplicationJson .. jmtUnknown] do
      if JanuaMimeString[a] = Value then
      begin
        self.FMimeType := a;
        Exit;
      end;
end;

procedure TJanuaMime.SetMimeType(const Value: TJanuaMimeType);
begin
  FMimeType := Value;
end;

{ TJanuaContent }

procedure TJanuaContent.Clear;
begin
  Unset;
  self.FContentType := TJanuaContentType.jctNotSet;
end;

constructor TJanuaContent.Create;
begin
  inherited;
  self.FStrings := TStringList.Create;
  self.FIsSet := false;
  self.FDigits := 6;
  self.FMaxLength := -1;
  self.FMinLength := -1;
  self.FMimeType := TJanuaMime.Create;
  self.FMimeType.MimeType := TJanuaMimeType.jmtUnknown;
  self.FContentType := TJanuaContentType.jctNotSet;
  self.FJsonObject := TJsonObject.Create;
end;

destructor TJanuaContent.Destroy;
begin
  if Assigned(self.FStrings) then
    FreeAndNil(self.FStrings);
  if Assigned(self.FMimeType) then
    FreeAndNil(self.FMimeType);
  inherited;
end;

function TJanuaContent.getAsBlob: TJanuaBlob;
var
  aStream: TMemoryStream;
begin
  Result := self.FBlob

end;

function TJanuaContent.GetAsJson: String;
begin
  Result := GetJsonObject.{$ifdef delphixe}ToJSON{$else}AsJson{$endif};
end;

function TJanuaContent.getAsString: String;
begin
  Result := self.getAsStrings.Text;
end;

function TJanuaContent.getAsStrings: TStrings;
var
  aStream: TStream;
begin
  if Assigned(self.FMemDataset) and (self.FContentType = TJanuaContentType.jctMemTable) then

  begin
    {$ifdef delphixe}
    aStream := self.FMemDataset.CreateXMLStream;
    {$else delphixe}
    aStream:= TMemoryStream.Create;
    FMemDataset.SaveToXML(aStream);
    {$endif delphixe}
    try
      aStream.Position := 0;
      self.FStrings.LoadFromStream(aStream);
    finally
      aStream.Free;
    end;
  end

  else if (FContentType = jctJsonObject) and Assigned(FJsonObject) and (FJsonObject.count > 0) then
  begin
    self.FStrings.Clear;
    self.FStrings.Text := Janua.Core.Functions.JsonPretty(self.FJsonObject);
  end;

  Result := FStrings;

end;

function TJanuaContent.GetJsonObject: TJsonObject;
var
  i: integer;
begin
  if not Assigned(self.FJsonObject) then
    self.FJsonObject := TJsonObject.Create;

  if Assigned(self.FStrings) and (self.FStrings.count > 0) then
  begin
    if self.FContentType = TJanuaContentType.jctParams then
    begin
      JsonObjectClear;
      for i := 0 to FStrings.count - 1 do
        JsonPair(FJsonObject, FStrings.Names[i], FStrings.ValueFromIndex[i]);
    end;
  end;

  Result := self.FJsonObject;
end;

{$ifdef delphixe}function TJanuaContent.geTFdMemTable: TFdMemTable;{$endif}
{$ifdef fpc}function TJanuaContent.geTFdMemTable: TVirtualTable;{$endif}
begin
  Result := self.FMemDataset;
end;

{
  procedure TJanuaContent.LoadFromDevartDataset(aDataset: TDataset);
  begin
  self.FBlob.Clear;
  if not Assigned(FMemDataset) then
  self.FMemDataset := TFdMemTable.Create(nil)
  else
  begin
  self.FMemDataset.ClearFields;
  self.FMemDataset.Close;
  end;
  Janua.Core.Functions.CloneDataset(aDataset, self.FMemDataset);
  self.FMimeType.MimeType := TJanuaMimeType.jmtApplicationXml;
  self.FContentType := TJanuaContentType.jcTFdMemTable;
  self.FMemDataset.Open;
  end;
}

procedure TJanuaContent.LoadFromFile(aFile: TFileName);
begin
  self.FBlob.Clear;
  if FileExists(aFile) then
    self.FBlob.LoadFromFile(aFile);
end;

procedure TJanuaContent.LoadFromStream(aStream: TStream);
begin
  case self.FMimeType.FMimeType of
    jmtApplicationJson:
      self.FStrings.LoadFromStream(aStream);
    jmtApplicationXml:
      self.FStrings.LoadFromStream(aStream);
    jmtTextHtml:
      self.FStrings.LoadFromStream(aStream);
    jmtTextCss:
      self.FStrings.LoadFromStream(aStream);
    jmtTextXml:
      self.FStrings.LoadFromStream(aStream);
    jmtTextPlain:
      self.FStrings.LoadFromStream(aStream);
    jmtOctetStream:
      self.FBlob.LoadFromStream(aStream);
    jmtApplicationJavascript:
      self.FStrings.LoadFromStream(aStream);
    jmtUnknown:
      self.FStrings.LoadFromStream(aStream);
  end;

end;

procedure TJanuaContent.SaveToFile(aFile: TFileName);
begin
  if true then

end;

procedure TJanuaContent.Unset;
begin
  self.FBlob.Clear;
  self.FStrings.Clear;
  self.FDigits := 6;
  self.FMaxLength := -1;
  self.MinLength := -1;
  self.FIsSet := false;
  JsonObjectClear;
end;

procedure TJanuaContent.JsonObjectClear;
begin
  if Assigned(self.FJsonObject) and (self.FJsonObject.count > 0) then
  begin
    self.FJsonObject.Free;
    self.FJsonObject := TJsonObject.Create;
  end;
end;

procedure TJanuaContent.SaveToStream(aStream: TStream);
begin
  if not Assigned(self.FStrings) then
    self.FStrings.Create;

  if (self.FContentType = TJanuaContentType.jctJsonObject) and Assigned(self.FJsonObject) then
  begin
    self.FStrings.Clear;
    self.FStrings.Text := self.GetAsJson;
    self.FStrings.SaveToStream(aStream);
  end
  else if self.FContentType in [jctXml, jctMemo, jctString] then
  begin
    self.FStrings.SaveToStream(aStream);
  end
  else if self.FContentType in [jctFile, jctImageFile, jctXml, jctBlob] then
    FBlob.SaveToStream(aStream);

end;

procedure TJanuaContent.setAsBlob(const Value: TJanuaBlob);
begin
  self.FBlob := Value;
  self.FContentType := TJanuaContentType.jctBlob;
end;

procedure TJanuaContent.SetasJson(const Value: string);
begin
  if self.FContentType = TJanuaContentType.jctJsonObject then
  begin
      {$ifdef delphixe}
          if not Assigned(self.FJsonObject) then
       FJsonObject := TJsonObject.Create;
       FJsonObject.Parse(BytesOf(Value), 0);
      {$endif}
      {$ifdef fpc}
       if Assigned(FJsonObject)  then FJsonObject.Free;
       FJsonObject := GetJSON(Value) as TJSONObject;
      {$endif}
  end;
end;

procedure TJanuaContent.setAsString(const Value: String);
begin
  if self.FContentType = TJanuaContentType.jctJsonObject then
  begin
    {$ifdef delphixe}
    if not Assigned(self.FJsonObject) then
       FJsonObject := TJsonObject.Create;
     FJsonObject.Parse(BytesOf(Value), 0);
    {$endif}
    {$ifdef fpc}
     if Assigned(FJsonObject)  then FJsonObject.Free;
     FJsonObject := GetJSON(Value) as TJSONObject;
    {$endif}
  end;
end;

procedure TJanuaContent.setAsStrings(const Value: TStrings);
begin

end;

procedure TJanuaContent.SetContentType(const Value: TJanuaContentType);
begin
  FContentType := Value;
end;

procedure TJanuaContent.SetDigits(const Value: smallint);
begin
  FDigits := Value;
end;

procedure TJanuaContent.SetIsSet(const Value: boolean);
begin
  FIsSet := Value;
end;

procedure TJanuaContent.SetJsonObject(const Value: TJsonObject);
var
  aString: string;
begin
  // self.FJsonObject := Value;
  {$ifdef delphixe}
  aString := Value.ToJSON;
  FJsonObject.Parse(BytesOf(aString), 0);
  {$endif}
  {$ifdef fpc}
  FJsonObject :=  TJsonObject(Value.Clone);
  {$endif}
end;

procedure TJanuaContent.SetMaxLength(const Value: integer);
begin
  FMaxLength := Value;
end;

procedure TJanuaContent.SetMimeType(const Value: TJanuaMime);
begin
  FMimeType := Value;
end;

procedure TJanuaContent.SetMinLength(const Value: integer);
begin
  FMinLength := Value;
end;

{$ifdef delphixe}
procedure TJanuaContent.seTFdMemTable(const Value: TFdMemTable);
begin

end;
{$endif}

{ TJanuaCoordinates }

procedure TJanuaCoordinates.Clear;
begin
  self.Latitude := 0.0;
  self.Longitude := 0.0;
end;

constructor TJanuaCoordinates.Create(aLat, aLon: Double);
begin
  self := Default (TJanuaCoordinates);
  self.FCoordinates.Latitude := aLat;
  self.FCoordinates.Longitude := aLon;
  //
end;

function TJanuaCoordinates.getAddress: string;
begin
  Result := self.FCoordinates.Address
end;

procedure TJanuaCoordinates.GetCoordinatesFromAddress;
begin

end;

function TJanuaCoordinates.getLatitude: Double;
begin
  Result := self.FCoordinates.Latitude
end;

function TJanuaCoordinates.getLongitude: Double;
begin
  Result := self.FCoordinates.Longitude
end;

procedure TJanuaCoordinates.SetAddress(const Value: string);
begin
  self.FCoordinates.Address := Value;
end;

procedure TJanuaCoordinates.SetCoordinates(const Value: TJanuaRecordCoordinates);
begin
  FCoordinates := Value;
end;

procedure TJanuaCoordinates.SetLatitude(const Value: Double);
begin
  self.FCoordinates.Latitude := Value;
end;

procedure TJanuaCoordinates.SetLongitude(const Value: Double);
begin
  self.FCoordinates.Longitude := Value;
end;

function TJanuaCoordinates.ToString: string;
begin
  Result := Format('Lat: %3.8f - Lon: %3.8f ', [FCoordinates.Latitude, FCoordinates.Longitude]);
end;

{ TJanuaRecordUserProfile }
{ TJanuaUserProfile }

function TJanuaRecordUserProfile.AsHtml(aTemplate: string): string;
begin
  Result := StringReplace(aTemplate, '$FirstName$', self.FirstName, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$LastName$', self.LastName, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$GenderCode$', self.Gender.GenderCode, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$BirthDate$', FormatDateTime('dd/mm/yyyy', BirthDate),
    [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$PublicEmail$', self.PublicEmail, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$FiscalCode$', self.FiscalCode, [rfReplaceAll, rfIgnoreCase]);
  Result := self.User.AsHtml(Result);
  Result := self.Address.AsHtml(Result);
end;

function TJanuaRecordUserProfile.asJson: string;
begin
  Result := Janua.Core.Functions.JsonPretty(self.asJsonObject);
end;

function TJanuaRecordUserProfile.AsRawHtml: string;
var
  aList: TStrings;
begin
  aList := TStringList.Create;
  try
    aList.Add('<p> FirstName: ' + self.FirstName + '<p>');
    aList.Add('<p> LastName: ' + self.LastName + '<p>');
    aList.Add('<p> Gender: ' + self.Gender.GenderName + '<p>');
    aList.Add('<p> Address: ' + self.Address.ToString + '<p>');
    aList.Add('<p> FiscalCode: ' + self.FiscalCode + '<p>');
    aList.Add(self.User.AsRawHtml);
  finally
    aList.Free;
  end;
end;

procedure TJanuaRecordUserProfile.Clear;
begin
  self.BirthLocation.Country.ID := 0;
  self.BirthLocation.Region.ID := 0;
  self.BirthLocation.District.ID := 0;
  self.BirthLocation.Town.ID := 0;
  self.Address.Location.Country.ID := 0;
  self.Address.Location.Region.ID := 0;
  self.Address.Location.District.ID := 0;
  self.Address.Location.Town.ID := 0;
  self.Gender.GenderType := TJanuaGenderType.NotSet;

  self.User.Clear;
end;

constructor TJanuaRecordUserProfile.Create(aGender: string);
begin
  self.Gender := TJanuaGender.Create(aGender);
  self.Address.Create('   ');
end;

function TJanuaRecordUserProfile.FullName: string;
begin
  if self.SecondName > '' then
    Result := FirstName + ' ' + SecondName + ' ' + LastName
  else
    Result := FirstName + ' ' + LastName;
end;

function TJanuaRecordUserProfile.GetJsonObject: TJsonObject;
begin
  Result := TJsonObject.Create;
  Janua.Core.Functions.JsonPair(Result, 'user', self.User.AsSJSONObJect);
  Janua.Core.Functions.JsonPair(Result, 'firstname', FirstName);
  Janua.Core.Functions.JsonPair(Result, 'gendercode', self.Gender.GenderCode);
  Janua.Core.Functions.JsonPair(Result, 'lastname', self.LastName);
  Janua.Core.Functions.JsonPair(Result, 'birthdate', self.BirthDate);
  Janua.Core.Functions.JsonPair(Result, 'publicemail', self.PublicEmail);
  Janua.Core.Functions.JsonPair(Result, 'fiscalcode', self.FiscalCode);
  Janua.Core.Functions.JsonPair(Result, 'address', self.Address.asJsonObject);
  Janua.Core.Functions.JsonPair(Result, 'birthlocation', self.BirthLocation.asJsonObject);
end;

procedure TJanuaRecordUserProfile.LoadFromDataset(dsUser, dsProfile: TDataset);
begin
  self.User.LoadFromDataset(dsUser);

  if Assigned(dsProfile) and (dsProfile.Active) and (dsProfile.RecordCount = 1) then
  begin
    self.FirstName := dsProfile.FieldByName('first_name').AsString;
    self.LastName := dsProfile.FieldByName('last_name').AsString;
    self.Title := dsProfile.FieldByName('title').AsString;
    self.FiscalCode := dsProfile.FieldByName('fiscal_code').AsString;

    self.Gender.GenderCode := dsProfile.FieldByName('gender_code').AsString;

    self.BirthDate := dsProfile.FieldByName('birth_date').AsDateTime;
    self.PublicEmail := dsProfile.FieldByName('public_email').AsString;

    // ************ Birth Location ***************************************************************
    if dsProfile.FieldByName('birth_country_id').AsInteger > 0 then
    begin
      self.BirthLocation.Country.ID := dsProfile.FieldByName('birth_country_id').AsInteger;
      self.BirthLocation.Region.ID := dsProfile.FieldByName('birth_region_id').AsInteger;
      self.BirthLocation.District.ID := dsProfile.FieldByName('birth_district_id').AsInteger;
      self.BirthLocation.Town.ID := dsProfile.FieldByName('birth_town_id').AsInteger;
    end;

    // ************ Address **********************************************************************
    self.Address.AddressFull := dsProfile.FieldByName('address_full').AsString;
    self.Address.Latitude := dsProfile.FieldByName('latitude').AsFloat;
    self.Address.Longitude := dsProfile.FieldByName('longitude').AsFloat;
    self.Address.Address := dsProfile.FieldByName('address_street').AsString;
    self.Address.Town := dsProfile.FieldByName('address_town').AsString;
    self.Address.Number := dsProfile.FieldByName('address_number').AsString;
    self.Address.postalcode := dsProfile.FieldByName('address_postal_code').AsString;
    self.Address.StateProvince := dsProfile.FieldByName('address_state_province').AsString;
    self.Address.Phone := dsProfile.FieldByName('phone').AsString;
    self.Address.CellularPhone := dsProfile.FieldByName('cellular_phone').AsString;
    self.Address.WorkPhone := dsProfile.FieldByName('work_phone').AsString;
    self.Address.FaxNumber := dsProfile.FieldByName('fax_number').AsString;
    self.Address.AddressMail := dsProfile.FieldByName('public_email').AsString;

    // ************ Indirizzo Location ***********************************************************
    if dsProfile.FieldByName('country_id').AsInteger > 0 then
    begin
      self.Address.Location.Country.ID := dsProfile.FieldByName('country_id').AsInteger;
      self.Address.Location.Region.ID := dsProfile.FieldByName('region_id').AsInteger;
      self.Address.Location.District.ID := dsProfile.FieldByName('district_id').AsInteger;
      self.Address.Location.Town.ID := dsProfile.FieldByName('town_id').AsInteger;
    end
    else
    begin
      self.Address.Location.Country.ID := 0;
      self.Address.Location.Region.ID := 0;
      self.Address.Location.District.ID := 0;
      self.Address.Location.Town.ID := 0;
    end;
  end;
end;

procedure TJanuaRecordUserProfile.LoadFromJsonObject(aJsonObject: TJsonObject);
var
  tmp: string;
begin
  self.User.AsSJSONObJect := Janua.Core.Functions.JsonObject('user', aJsonObject);
  self.Address.asJsonObject := Janua.Core.Functions.JsonObject('address', aJsonObject);
  BirthLocation.asJsonObject := Janua.Core.Functions.JsonObject('birthlocation', aJsonObject);
  Janua.Core.Functions.JsonValue(aJsonObject, 'firstname', FirstName);
  Janua.Core.Functions.JsonValue(aJsonObject, 'lastname', self.LastName);
  Janua.Core.Functions.JsonValue(aJsonObject, 'gendercode', tmp);
  self.Gender.GenderCode := tmp;
  Janua.Core.Functions.JsonValue(aJsonObject, 'birthdate', self.BirthDate);
  Janua.Core.Functions.JsonValue(aJsonObject, 'publicemail', self.PublicEmail);
  Janua.Core.Functions.JsonValue(aJsonObject, 'fiscalcode', self.FiscalCode);
end;

{$IF Defined(WEBBROKER)}

procedure TJanuaRecordUserProfile.LoadFromHttpParams(aRequest: TWebRequest);
begin
  // Eseguo il Clear prima del caricamento dai parametri solo se si tratta di un nuovo profilo utente e quello
  // di sessione non è attivo, oppure se non si tratta di un profilo di sessione dell'utente Public.
  if (self.User.ID = 0) or (self.User.isPublic) then
    self.Clear;
  self.User.LoadFromHttpParams(aRequest);

  if HttpGetParamValue(aRequest, 'title') <> '' then
    self.Title := HttpGetParamValue(aRequest, 'title');
  if HttpGetParamValue(aRequest, 'first_name') <> '' then
    self.FirstName := HttpGetParamValue(aRequest, 'first_name');
  if HttpGetParamValue(aRequest, 'last_name') <> '' then
    self.LastName := HttpGetParamValue(aRequest, 'last_name');
  self.Gender.GenderCode := HttpGetParamValue(aRequest, 'gender');
  if HttpGetParamValue(aRequest, 'birth_date') <> '' then
    self.BirthDate := HttpParseDate(HttpGetParamValue(aRequest, 'birth_date'));
  { TODO : Testare funzione di conversione data yyyy-mm-dd in delphi }
  if HttpGetParamValue(aRequest, 'public_email') <> '' then
    self.PublicEmail := HttpGetParamValue(aRequest, 'public_email');
  if HttpGetParamValue(aRequest, 'fiscalcode') <> '' then
    self.FiscalCode := HttpGetParamValue(aRequest, 'fiscalcode');

  self.Address.LoadFromHttpParams(aRequest);

  if HttpGetParamValue(aRequest, 'full_address') <> '' then
    self.Address.AddressFull := HttpGetParamValue(aRequest, 'full_address');
  if HttpGetParamValue(aRequest, 'town') <> '' then
    self.Address.Location.Town.Name := HttpGetParamValue(aRequest, 'town');
  if HttpGetParamValue(aRequest, 'address') <> '' then
    self.Address.Address := HttpGetParamValue(aRequest, 'address');
  if HttpGetParamValue(aRequest, 'state_province') <> '' then
    self.Address.Location.District.Code := HttpGetParamValue(aRequest, 'state_province');

  if (HttpGetParamValue(aRequest, 'lat') <> '') // and IsNumeric(HttpGetParamValue(aRequest, 'lat'))
  then
    self.Address.Latitude := HttpParseNumber(HttpGetParamValue(aRequest, 'lat'));

  if (HttpGetParamValue(aRequest, 'lng') <> '') // and IsNumeric(HttpGetParamValue(aRequest, 'lng'))
  then
    self.Address.Longitude := HttpParseNumber(HttpGetParamValue(aRequest, 'lng'));

  if HttpGetParamValue(aRequest, 'avatar_img_url') <> '' then
    self.User.AvatarImageUrl := HttpGetParamValue(aRequest, 'avatar_img_url');

end;
{$ENDIF Defined(WEBBROKER)}

procedure TJanuaRecordUserProfile.SaveToDataset(dsUser, dsProfile: TDataset);
begin
  // active, email, db_user_id, password, username, isactive, verify_token, verified,
  // default_schema_id, ispublic, internal_key, default_role_id, search_name, reverse_search,
  // insert_date, country_id, main_profile_type_id, main_profile_id, image_id, image_url
  // iso_language_code, iso_culture_code

  if Assigned(dsUser) and (dsUser.RecordCount > 0) then
    self.User.SaveToDataset(dsUser);

  if Assigned(dsProfile) and (dsProfile.Active) then
  begin
    if dsProfile.RecordCount = 0 then
      dsProfile.Append;
    dsProfile.Edit;
    dsProfile.FieldByName('db_user_id').AsInteger := self.User.ID;
    dsProfile.FieldByName('title').AsString := self.Title;
    dsProfile.FieldByName('first_name').AsString := self.FirstName;
    dsProfile.FieldByName('last_name').AsString := self.LastName;
    dsProfile.FieldByName('facebook_json').AsString := self.FacebookJSON;

    if (self.Gender.GenderCode = 'M') or (self.Gender.GenderCode = 'S') then
      dsProfile.FieldByName('gender_code').AsString := self.Gender.GenderCode
    else
      dsProfile.FieldByName('gender_code').AsString := 'M';

    dsProfile.FieldByName('birth_date').AsDateTime := self.BirthDate;
    dsProfile.FieldByName('public_email').AsString := self.PublicEmail;
    dsProfile.FieldByName('fiscal_code').AsString := self.FiscalCode;

    // ************ Birth Location ******************************************************************
    if self.BirthLocation.Country.ID > 0 then
    begin
      dsProfile.FieldByName('birth_country_id').AsInteger := self.BirthLocation.Country.ID;
      dsProfile.FieldByName('birth_region_id').AsInteger := self.BirthLocation.Region.ID;
      dsProfile.FieldByName('birth_district_id').AsInteger := self.BirthLocation.District.ID;
      dsProfile.FieldByName('birth_town_id').AsInteger := self.BirthLocation.Town.ID;
    end;
    // ************ Indirizzo ***********************************************************************
    dsProfile.FieldByName('address_street').AsString := self.Address.Address;
    dsProfile.FieldByName('address_town').AsString := self.Address.Town;
    dsProfile.FieldByName('address_number').AsString := self.Address.Number;
    dsProfile.FieldByName('address_postal_code').AsString := self.Address.postalcode;
    dsProfile.FieldByName('address_state_province').AsString := self.Address.StateProvince;
    dsProfile.FieldByName('phone').AsString := self.Address.Phone;
    dsProfile.FieldByName('cellular_phone').AsString := self.Address.CellularPhone;
    dsProfile.FieldByName('work_phone').AsString := self.Address.WorkPhone;
    dsProfile.FieldByName('fax_number').AsString := self.Address.FaxNumber;
    dsProfile.FieldByName('address_full').AsString := self.Address.AddressFull;
    dsProfile.FieldByName('latitude').AsFloat := self.Address.Latitude;
    dsProfile.FieldByName('longitude').AsFloat := self.Address.Longitude;

    dsProfile.FieldByName('smssent').AsBoolean := self.Address.SMSSent;
    dsProfile.FieldByName('smsconfirmed').AsBoolean := self.Address.SMSConfirmed;
    dsProfile.FieldByName('smsdate').AsDateTime := self.Address.SMSDate;
    dsProfile.FieldByName('smschecknumber').AsWideString := self.Address.SMSCheckNumber;
    // ************ Indirizzo Location **************************************************************
    if self.Address.Location.Country.ID > 0 then
    begin
      dsProfile.FieldByName('country_id').AsInteger := self.Address.Location.Country.ID;
      dsProfile.FieldByName('region_id').AsInteger := self.Address.Location.Region.ID;
      dsProfile.FieldByName('district_id').AsInteger := self.Address.Location.District.ID;
      dsProfile.FieldByName('town_id').AsInteger := self.Address.Location.Town.ID;
    end;
    if dsProfile.State in [dsInsert, dsEdit] then
      dsProfile.Post;
  end;
end;

procedure TJanuaRecordUserProfile.SetUser(const Value: TJanuaUser);
begin
  FUser := Value;
end;

function TJanuaRecordUserProfile.ToString: string;
begin
  Result := 'Username ' + User.Username + sLineBreak + 'Email ' + User.Email + sLineBreak + 'Password ' +
    User.Password + sLineBreak + 'Key ' + User.Key + sLineBreak + 'ID ' + User.ID.ToString + sLineBreak +
    'Role ' + User.role_name + sLineBreak + 'FirstName ' + FirstName + sLineBreak + 'LastName ' + LastName +
    sLineBreak + 'BirthDate ' + DateToStr(BirthDate) + sLineBreak + 'BirthLocation ' + sLineBreak +
    BirthLocation.ToString + sLineBreak + 'Address: ' + sLineBreak + Address.ToString;

end;

{ TJanuaUser }
{ TJanuaUser }

function TJanuaUser.AsHtml(aTemplate: string): string;
begin
  Result := StringReplace(aTemplate, '$Username$', self.Username, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$Email$', self.Email, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$Password$', self.Password, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$Key$', self.Key, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$id$', self.ID.ToString, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$role_name$', self.role_name, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$role_id$', self.role_id.ToString, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$SocialID$', self.SocialID, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$SocialType$', self.SocialType, [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$AvatarImageID$', self.AvatarImageID.ToString,
    [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, '$AvatarImageUrl$', self.AvatarImageUrl, [rfReplaceAll, rfIgnoreCase]);
end;

function TJanuaUser.AsRawHtml: string;
var
  aList: TStrings;
begin
  aList := TStringList.Create;
  try
    aList.Add('<p> Username: ' + self.Username + '<p>');
    aList.Add('<p> Email: ' + self.Email + '<p>');
    aList.Add('<p> Key: ' + Key + '<p>');
    aList.Add('<p> id: ' + self.ID.ToString + '<p>');
    aList.Add('<p> AvatarImage_URL: ' + self.AvatarImageUrl + '<p>');
  finally
    aList.Free;
  end;

end;

procedure TJanuaUser.Clear;
begin
  Username := '';
  SocialID := '';
  SocialTypeID := 0;
  SocialType := '';
  Email := '';
  EmailSent := false;
  EmailDate := 0.0;
  EmailConfirmed := false;
  Password := '';
  RPassword := '';
  Key := '';
  ID := 0;
  role_id := 0;
  role_name := '';
  IsoLanguageCode := 'it';
  IsoCultureCode := 'it_it';
  AvatarImageID := 0;
  AvatarImageUrl := '';
  isPublic := false;
end;

function TJanuaUser.GetJsonObject: TJsonObject;
begin
  Result := TJsonObject.Create;
  Janua.Core.Functions.JsonPair(Result, 'username', self.Username);
  Janua.Core.Functions.JsonPair(Result, 'email', self.Email);
  Janua.Core.Functions.JsonPair(Result, 'password', self.Password);
  Janua.Core.Functions.JsonPair(Result, 'key', self.Key);
  Janua.Core.Functions.JsonPair(Result, 'id', self.ID);
  Janua.Core.Functions.JsonPair(Result, 'role_id', self.role_id);
  Janua.Core.Functions.JsonPair(Result, 'role_name', self.role_name);
  Janua.Core.Functions.JsonPair(Result, 'social_id', self.SocialID);
  Janua.Core.Functions.JsonPair(Result, 'social_network', self.SocialType);
  Janua.Core.Functions.JsonPair(Result, 'avatarimage_id', self.AvatarImageID);
  Janua.Core.Functions.JsonPair(Result, 'avatarimage_url', self.AvatarImageUrl);
  Janua.Core.Functions.JsonPair(Result, 'ispublic', self.isPublic);
  Janua.Core.Functions.JsonPair(Result, 'payment', self.Payment);
  Janua.Core.Functions.JsonPair(Result, 'payment_expiration_date', self.PaymentExpiration);
end;

function TJanuaUser.GetRoleByID(aID: integer): boolean;
var
  aRegion: TJanuaRole;
begin
  Result := false;
  for aRegion in self.Roles do
    if aRegion.ID = aID then
    begin
      Result := true;
      self.SelectedRole := aRegion;
      Exit;
    end;
end;

function TJanuaUser.GetRolebyIndex(aIndex: integer): boolean;
var
  aRegion: TJanuaRole;
begin
  Result := false;
  for aRegion in self.Roles do
    if aRegion.index = aIndex then
    begin
      Result := true;
      self.SelectedRole := aRegion;
      Exit;
    end;
end;

function TJanuaUser.getRoleByName(aName: string): boolean;
var
  aRegion: TJanuaRole;
begin
  Result := false;
  for aRegion in self.Roles do
    if UpperCase(aRegion.Name) = UpperCase(aName) then
    begin
      Result := true;
      self.SelectedRole := aRegion;
      Exit;
    end;
end;

procedure TJanuaUser.LoadFromDataset(dsUser: TDataset);
begin
  if Assigned(dsUser) and (dsUser.Active) and (dsUser.RecordCount = 1) then
  begin
    self.role_id := dsUser.FieldByName('default_role_id').AsInteger;
    self.Key := dsUser.FieldByName('verify_token').AsString;
    self.ID := dsUser.FieldByName('db_user_id').AsInteger;
    self.Email := dsUser.FieldByName('email').AsString;
    self.Username := dsUser.FieldByName('username').AsString;
    self.AvatarImageUrl := dsUser.FieldByName('image_url').AsString;
    // gli utenti Public hanno la proprietà Public impostata a true, gli utenti Public sono creati
    // automaticamente dal sistema con nome utente = <schema.name>+nobody e mail = nobody@schema.url
    self.isPublic := dsUser.FieldByName('ispublic').AsBoolean;

    EmailSent := dsUser.FieldByName('emailsent').AsBoolean;
    EmailDate := dsUser.FieldByName('emaildate').AsDateTime;
    EmailConfirmed := dsUser.FieldByName('emailconfirmed').AsBoolean;

    Janua.Core.Functions.GetFieldValue(self.FPayment, dsUser, 'payment', false);
    Janua.Core.Functions.GetFieldValue(self.FPaymentExpiration, dsUser, 'payment_expiration_date', false);

    // facebook-871436576288123
    if Pos('facebook', self.Username) > 0 then
    begin
      self.SocialID := StringReplace(self.Username, 'facebook-', '', [rfReplaceAll]);
      self.SocialType := 'Facebook';
    end;
  end;
end;

procedure TJanuaUser.LoadFromJsonObject(aJsonObject: TJsonObject);
begin
  Janua.Core.Functions.JsonValue(aJsonObject, 'username', self.FUsername);
  Janua.Core.Functions.JsonValue(aJsonObject, 'email', self.FEmail);
  Janua.Core.Functions.JsonValue(aJsonObject, 'password', self.FPassword);
  Janua.Core.Functions.JsonValue(aJsonObject, 'key', self.FKey);
  Janua.Core.Functions.JsonValue(aJsonObject, 'id', self.FID);
  Janua.Core.Functions.JsonValue(aJsonObject, 'role_id', self.Frole_id);
  Janua.Core.Functions.JsonValue(aJsonObject, 'role_name', self.Frole_name);
  Janua.Core.Functions.JsonValue(aJsonObject, 'social_id', self.FSocialID);
  Janua.Core.Functions.JsonValue(aJsonObject, 'social_network', self.FSocialType);
  Janua.Core.Functions.JsonValue(aJsonObject, 'avatarimage_id', self.FAvatarImageID);
  Janua.Core.Functions.JsonValue(aJsonObject, 'avatarimage_url', self.FAvatarImageUrl);
  Janua.Core.Functions.JsonValue(aJsonObject, 'ispublic', self.FisPublic);
  Janua.Core.Functions.JsonValue(aJsonObject, 'payment_expiration_date', self.FPaymentExpiration);
  Janua.Core.Functions.JsonValue(aJsonObject, 'payment', self.FPayment);
end;

{$IF Defined(WEBBROKER)}

procedure TJanuaUser.LoadFromHttpParams(aRequest: TWebRequest);
begin
  // First Part is the User  .........................................................
  if HttpGetParamValue(aRequest, 'email') <> '' then
    self.Email := HttpGetParamValue(aRequest, 'email');
  // se la password è inserita in login è password  se form di registrazione è
  // register password................................................................
  if HttpGetParamValue(aRequest, 'password') <> '' then
    self.Password := HttpGetParamValue(aRequest, 'password')
  else if HttpGetParamValue(aRequest, 'register_password') <> '' then
    self.Password := HttpGetParamValue(aRequest, 'password');

  if HttpGetParamValue(aRequest, 'rpassword') <> '' then
    self.RPassword := HttpGetParamValue(aRequest, 'rpassword');
  if HttpGetParamValue(aRequest, 'iso_lang_code') <> '' then
    self.IsoLanguageCode := HttpGetParamValue(aRequest, 'iso_lang_code');
  if HttpGetParamValue(aRequest, 'iso_culture_code') <> '' then
    self.IsoCultureCode := HttpGetParamValue(aRequest, 'iso_culture_code');
  if HttpGetParamValue(aRequest, 'username') <> '' then
    self.Username := HttpGetParamValue(aRequest, 'username');
end;
{$ENDIF Defined(WEBBROKER)}

procedure TJanuaUser.SaveToDataset(dsUser: TDataset);
begin
  if Assigned(dsUser) and dsUser.Active then
  begin
    dsUser.Edit;
    dsUser.FieldByName('email').AsString := self.Email;
    dsUser.FieldByName('iso_language_code').AsString := self.IsoLanguageCode;
    dsUser.FieldByName('iso_culture_code').AsString := self.IsoCultureCode;
    dsUser.FieldByName('image_url').AsString := self.AvatarImageUrl;
    dsUser.FieldByName('emailsent').AsBoolean := self.EmailSent;
    dsUser.FieldByName('emailconfirmed').AsBoolean := self.EmailConfirmed;
    dsUser.FieldByName('emaildate').AsDateTime := self.EmailDate;
    dsUser.Post;
  end;
end;

procedure TJanuaUser.SetAvatarImageID(const Value: Int64);
begin
  FAvatarImageID := Value;
end;

procedure TJanuaUser.SetAvatarImageUrl(const Value: string);
begin
  FAvatarImageUrl := Value;
end;

procedure TJanuaUser.SetEmail(const Value: string);
begin
  FEmail := Value;
end;

procedure TJanuaUser.SetEmailConfirmed(const Value: boolean);
begin
  FEmailConfirmed := Value;
end;

procedure TJanuaUser.SetEmailDate(const Value: TDateTime);
begin
  FEmailDate := Value;
end;

procedure TJanuaUser.SetEmailSent(const Value: boolean);
begin
  FEmailSent := Value;
end;

procedure TJanuaUser.SetID(const Value: Int64);
begin
  FID := Value;
end;

procedure TJanuaUser.SetIsoCultureCode(const Value: string);
begin
  FIsoCultureCode := Value;
end;

procedure TJanuaUser.SetIsoLanguageCode(const Value: string);
begin
  FIsoLanguageCode := Value;
end;

procedure TJanuaUser.SetisPublic(const Value: boolean);
begin
  FisPublic := Value;
end;

procedure TJanuaUser.SetKey(const Value: string);
begin
  FKey := Value;
end;

procedure TJanuaUser.SetPassword(const Value: string);
begin
  FPassword := Value;
end;

procedure TJanuaUser.SetPayment(const Value: boolean);
begin
  FPayment := Value;
end;

procedure TJanuaUser.SetPaymentExpiration(const Value: TDate);
begin
  FPaymentExpiration := Value;
end;

procedure TJanuaUser.SetRoleByID(aID: smallint);
begin
  if self.GetRoleByID(aID) then
  begin
    self.role_id := self.SelectedRole.ID;
    self.role_name := self.SelectedRole.Name;
  end;
end;

procedure TJanuaUser.SetRoles(const Value: TArrayRoles);
begin
  FRoles := Value;
end;

procedure TJanuaUser.Setrole_id(const Value: smallint);
begin
  Frole_id := Value;
end;

procedure TJanuaUser.Setrole_name(const Value: string);
begin
  Frole_name := Value;
end;

procedure TJanuaUser.SetRPassword(const Value: string);
begin
  FRPassword := Value;
end;

procedure TJanuaUser.SetSelectedRole(const Value: TJanuaRole);
begin
  FSelectedRole := Value;
end;

procedure TJanuaUser.SetSocialID(const Value: string);
begin
  FSocialID := Value;
end;

procedure TJanuaUser.SetSocialType(const Value: string);
begin
  FSocialType := Value;
end;

procedure TJanuaUser.SetSocialTypeID(const Value: smallint);
begin
  FSocialTypeID := Value;
end;

procedure TJanuaUser.SetUsername(const Value: string);
begin
  FUsername := Value;
end;

function TJanuaUser.ToJSON: string;
var
  Temp: TJsonObject;
begin
  Temp := self.AsSJSONObJect;
  Result := Temp.ToString;
  Temp.Free;
end;

function TJanuaUser.ToString: string;
begin
  Result := 'Username =  ' + Username + ', Email: ' + Email + ', Password: ' + Password + ', Key: ' + Key +
    ', id: ' + ID.ToString;

end;

{ TJanuaRecordSchema }

procedure TJanuaRecordSchema.Clear;
begin
  ID := 0;
  Name := '';
  schema_des := '';
  /// <summary>
  /// -- This column tell us if this schema is linked to a person as a
  /// personal schema to store owner's data, password, and profiles
  /// </summary>
  personal := false;
  db_schema_key := '';
  country_id := 0;
  language_id := 0;
  /// <summary>
  /// Defa
  /// </summary>
  default_user_id := 0;
end;

{ TJanuaCustomObject }

procedure TJanuaCustomObject.SetName(const Value: string);
begin
  FName := Value;
end;

{ TJanuaCustomPersistent }

function TJanuaCustomPersistent.Activate: boolean;
begin
  self.FActive := true;
  Result := true;
end;

procedure TJanuaCustomPersistent.Deactivate;
begin
  self.FActive := false;
end;

procedure TJanuaCustomPersistent.SetActive(const Value: boolean);
begin
  FActive := Value;
end;

procedure TJanuaCustomPersistent.SetName(const Value: string);
begin
  self.FName := Value;
end;

{ TJanuaFileCache }

constructor TJanuaFileCache.Create(AOwner: TComponent);
begin
  inherited;
  FTextFiles := TDictionary<String, String>.Create;
  FFileLoader := TStringList.Create;
end;

destructor TJanuaFileCache.Destroy;
begin
  if Assigned(self.FTextFiles) then
    self.FTextFiles.Free;
  if Assigned(self.FFileLoader) then
    self.FFileLoader.Free;
  inherited;
end;

function TJanuaFileCache.SearchFile(aDirectory, aFile: string): boolean;
var
  sFile: string;
  conto, i: integer;
begin
  sFile := '';
  if (self.FHomeDir <> '') then
    sFile := sFile + IncludeTrailingPathDelimiter(self.FHomeDir);
  if (aDirectory <> '') then
    sFile := sFile + IncludeTrailingPathDelimiter(aDirectory);
  sFile := sFile + aFile;
  self.FFound := self.FTextFiles.ContainsKey(aFile.ToLower);

  conto := FTextFiles.count;
  {
    if not self.FFound then
    begin
    for i := 0 to FTextFiles.Count - 1 do

    end;
  }

  if self.FFound then
    FTextFiles.TryGetValue(sFile.ToLower, self.FSelectedFile)
  else
  begin
    self.FFound := FileExists(sFile);
    if self.FFound then
    begin
      self.FFileLoader.LoadFromFile(sFile);
      // imposto la variabile interna con il valore Text di FFileLoader
      self.FSelectedFile := self.FFileLoader.Text;
      // dopo file Loader non serve più ed eseguo un Clear della variabile del loader
      self.FFileLoader.Clear;
      // se il file è stato caricato correttamente lo carico indicizzandolo con il suo Full-Path .......
      self.FTextFiles.Add(aFile.ToLower, FSelectedFile);
    end;
  end;
  Result := self.FFound;
end;

procedure TJanuaFileCache.SetFound(const Value: boolean);
begin
  FFound := Value;
end;

procedure TJanuaFileCache.SetHomeDir(const Value: string);
begin
  FHomeDir := Value;
end;

procedure TJanuaFileCache.SetSelectedFile(const Value: string);
begin
  FSelectedFile := Value;
end;

procedure TJanuaFileCache.SetTextFiles(const Value: TDictionary<String, String>);
begin
  self.FTextFiles := Value;
end;

{ TJanuaJsonDacDataset }

procedure TJanuaJsonDacDataset.AfterPost(aDataset: TDataset);
begin
  if not self.FPostDataset.Locate(self.FKeyFields.Text, aDataset.FieldByName(self.FKeyFields.Text).Value, [])
  then
    FPostDataset.Append;
  Janua.Core.Functions.CopyRecord(aDataset, self.FPostDataset);
end;

function TJanuaJsonDacDataset.asJson: string;
var
  aObject: TJsonObject;
begin
  aObject := asJsonObject;
  try
    {$ifdef delphixe}Result := aObject.ToJSON; {$endif}
    {$ifdef fpc}Result := aObject.AsJSON; {$endif}
  finally
    aObject.Free;
  end;

end;

function TJanuaJsonDacDataset.asJsonObject: TJsonObject;
begin
  Result := TJsonObject.Create;
  if Assigned(FMemDataset) then
  begin
    Janua.Core.Functions.JsonPair(Result, 'count', self.FMemDataset.RecordCount);
    Janua.Core.Functions.JsonPair(Result, 'name', self.Name);
    Janua.Core.Functions.JsonPair(Result, 'datasetname', self.FMemDataset.Name);
    {$ifdef delphixe}
    if (self.IsVirtualTable) and (self.FMemDataset is TFdMemTable) then
      ExportDatasetToBase64String(FMemDataset as TFdMemTable, FEncodedDataset)
    else
      Janua.Core.Functions.ExportDatasetToBase64String(self.FMemDataset, FEncodedDataset);
    {$endif}
    {$ifdef fpc}
    if (self.IsVirtualTable) and (self.FMemDataset is TVirtualTable) then
      ExportDatasetToBase64String(FMemDataset as TVirtualTable, FEncodedDataset)
    else
      Janua.Core.Functions.ExportDatasetToBase64String(self.FMemDataset, FEncodedDataset);
    {$endif}

    Janua.Core.Functions.JsonPair(Result, 'dataset', FEncodedDataset);
  end
  else
  begin
    raise Exception.Create('TJanuaJsonDacDataset.AsJsonObject Error FMemDataset not Set');
  end;
end;

procedure TJanuaJsonDacDataset.Close;
begin
  if Assigned(FMemDataset) then
    self.FMemDataset.Close;
end;

constructor TJanuaJsonDacDataset.Create(AOwner: TComponent);
begin
  inherited;
  DestroyInternalDataset;
  self.FDecodedDataset := TStringList.Create;
  self.FJsonObject := TJsonObject.Create;
  self.FKeyFields := TStringList.Create;
  // self.FParams := TJanuaParams.Create;
end;

procedure TJanuaJsonDacDataset.CreateInternalDataset;
begin
  {$ifdef delphixe}
  self.FPostDataset := TFdMemTable.Create(nil);
  self.FDelDataset := TFdMemTable.Create(nil);
  {$endif}
  {$ifdef fpc}
  self.FPostDataset := TVirtualTable.Create(nil);
  self.FDelDataset := TVirtualTable.Create(nil);
  {$endif}
  FPostDataset.AfterPost := self.AfterPost;
end;

destructor TJanuaJsonDacDataset.Destroy;
begin
  if Assigned(FDecodedDataset) then
    FDecodedDataset.Free;
  if Assigned(FJsonObject) then
    FJsonObject.Free;
  if Assigned(FKeyFields) then
    FKeyFields.Free;
  inherited;
end;

procedure TJanuaJsonDacDataset.DestroyInternalDataset;
begin
  if Assigned(FPostDataset) then
    FPostDataset.Free;
  if Assigned(FDelDataset) then
    FDelDataset.Free;

end;

function TJanuaJsonDacDataset.FieldByName(const FieldName: string): TField;
begin
  if Assigned(MemDataset) then
    Result := self.MemDataset.FieldByName(FieldName)
  else
    raise Exception.Create('TJanuaJsonDacDataset.FieldByName Dataset not set ');
end;

function TJanuaJsonDacDataset.getRecordCount: integer;
begin
  if Assigned(self.FMemDataset) then
    Result := self.FMemDataset.RecordCount
  else
    Result := -1;

end;

procedure TJanuaJsonDacDataset.LoadFromFile(const FileName: string);
var
  aStrings: TStrings;
begin
  aStrings := TStringList.Create;
  try
    aStrings.Text := self.asJson;
    aStrings.LoadFromFile(FileName);
  finally
    aStrings.Free;
  end;
end;

procedure TJanuaJsonDacDataset.LoadFromJson(aJson: string);
var
  vParsed: integer;
begin
  self.FJsonObject := Janua.Core.Functions.JsonParse(aJson);

  // vParsed := FJsonObject.Parse(BytesOf(AJson), 0);
  // if vParsed <= 0 then
  // raise exception.Create('Janua Core Functions Error in Json Parse, not a json text');

  self.LoadFromJsonObject(FJsonObject);
end;

procedure TJanuaJsonDacDataset.CreateVirtualTable;
begin
  if not Assigned(FMemDataset) {$ifdef delphixe}or not(FMemDataset is TFdMemTable){$endif} then
  begin
    FMemDataset := nil;
    self.FVirtualTable := {$ifdef delphixe}TFdMemTable{$else}TVirtualTable{$endif}.Create(self);
    self.FVirtualTable.Name := self.Name;
    self.FMemDataset := self.FVirtualTable;
    self.FIsVirtualTable := true;
    self.WriteLog('TJanuaJsonDacDataset.CreateVirtualTable Create Virtual Table: ' + FMemDataset.Name);
  end;
end;

procedure TJanuaJsonDacDataset.AssignDataset(aDataset: TDataset);
begin
  CreateVirtualTable;
  if Assigned(aDataset) and Assigned(FMemDataset) then
  begin
    self.IsVirtualTable := true;
    FVirtualTable.Close;
    {$ifdef delphixe}
    FVirtualTable.CopyDataSet(aDataset, [coStructure, coRestart, coAppend]); // ();
    {$else}
    {$endif}
    // Janua.Core.Functions.CloneDataset(aDataset, self.FVirtualTable);
    FVirtualTable.Open;
  end;
end;

procedure TJanuaJsonDacDataset.AssignDatasource;
begin
  if Assigned(self.FMemDataset) and Assigned(FDataSource) then
    self.FDataSource.Dataset := self.FMemDataset;
end;

procedure TJanuaJsonDacDataset.LoadFromJsonObject(aObject: TJsonObject);
var
  stream: TBytesStream;
  // stream: TBytesStream;
begin
  Assert(Assigned(aObject), 'JanuaJsonDacDataset.LoadFromJsonObject Error object is not set');

  Janua.Core.Functions.JsonValue(aObject, 'dataset', self.FEncodedDataset);

  if not Assigned(self.FMemDataset) then
    self.CreateVirtualTable;

  {$ifdef delphixe}
  if (FEncodedDataset > '') and (self.IsVirtualTable) and (FMemDataset is TFdMemTable) then
  begin
    stream := TBytesStream.Create(DecodeBase64(StringToAnsiString(FEncodedDataset)));
    try
      (FMemDataset as TFdMemTable).LoadFromStream(stream);
    finally
      stream.Free;
    end;
  end;
  {$endif}


  {$ifdef fpc}
    if (self.IsVirtualTable) and (FMemDataset is TVirtualTable) then
    begin

    end
    else
    begin
      // self.FMemDataset.Text := Janua.Core.Functions.Decode64(self.FEncodedDataset);
      if Assigned(self.FMemDataset) and (self.FMemDataset is TVirtualTable) and (self.FDecodedDataset.count > 0) then
    begin
      Janua.Core.Functions.ImportDatasetFromXMLMemo((self.FMemDataset as TVirtualTable), self.FDecodedDataset);
    end;
    end;
  {$endif fpc}

  if not self.FMemDataset.Active then
    self.FMemDataset.Open;
end;

procedure TJanuaJsonDacDataset.Open;
begin
  if Assigned(FMemDataset) and not self.FMemDataset.Active then
    self.FMemDataset.Open;
end;

procedure TJanuaJsonDacDataset.SaveToFile(const FileName: string);
var
  aStrings: TStrings;
begin
  aStrings := TStringList.Create;
  try
    aStrings.Text := self.asJson;
    aStrings.LoadFromFile(FileName);
  finally
    aStrings.Free;
  end;

end;

procedure TJanuaJsonDacDataset.SetDataSource(const Value: TDataSource);
begin
  FDataSource := Value;
  AssignDatasource;
end;

procedure TJanuaJsonDacDataset.SetDecodedDataset(const Value: TStrings);
begin
  FDecodedDataset := Value;
end;

procedure TJanuaJsonDacDataset.SetEncodedDataset(const Value: string);
begin
  FEncodedDataset := Value;
end;

procedure TJanuaJsonDacDataset.SetisReadOny(const Value: boolean);
begin
  FisReadOny := Value;
end;

procedure TJanuaJsonDacDataset.SetIsVirtualTable(const Value: boolean);
begin
  if FIsVirtualTable and not Value then
  begin
    if Assigned(self.FMemDataset) then
      FreeAndNil(FMemDataset)
  end
  else if Value and not FIsVirtualTable then
    CreateVirtualTable;

  self.FIsVirtualTable := Value;
end;

procedure TJanuaJsonDacDataset.SetJsonObject(const Value: TJsonObject);
begin
  FJsonObject := Value;
end;

procedure TJanuaJsonDacDataset.SetKeyFields(const Value: TStrings);
begin
  FKeyFields := Value;
end;

(*
  procedure TJanuaJsonDacDataset.SetParams(const Value: TJanuaParams);
  begin
  FParams := Value;
  end;
*)

procedure TJanuaJsonDacDataset.seTFdMemTable(const Value: TDataset);
begin
  FMemDataset := Value;
  AssignDatasource;
end;

{ TJanuaDatasetClient }

procedure TJanuaDatasetClient.SetDataset(const Value: TJanuaJsonDacDataset);
begin
  FDataset := Value;
end;

{ TJanuaDatasetProvider }

procedure TJanuaDatasetProvider.SetDataset(const Value: TJanuaJsonDacDataset);
begin
  FDataset := Value;
end;

{ TJanuaJsonParser }

constructor TJanuaJsonParser.Create;
begin
  FIndex := TDictionary<string, TJsonValue>.Create;
end;

constructor TJanuaJsonParser.Create(aObject: TJsonObject);
begin
  self.Create;
  self.SetasJsonObject(aObject);
end;

destructor TJanuaJsonParser.Destroy;
begin
  FreeAndNil(FIndex);
  inherited;
end;

function TJanuaJsonParser.FindKey(aKey: string): TJsonValue;
begin
  if not FIndex.TryGetValue(aKey, Result) then
    Result := nil;
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: Int64);
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := TJSONNumber(FIndex.items[aParam.ToLower]).Value.ToInt64()
  else
    aValue := 0;
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: integer);
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := TJSONNumber(FIndex.items[aParam.ToLower]).Value.ToInteger()
  else
    aValue := 0;
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: string);
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := FIndex.items[aParam.ToLower].Value
  else
    aValue := '';

  // S := aObject.Get(aParam).JsonValue as TJSONString;
  // aValue := S.Value
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: TDateTime);
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := JsonDecodeDate(FIndex.items[aParam.ToLower].Value)
  else
    aValue := 0.0;
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: Extended);
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := TJSONNumber(FIndex.items[aParam.ToLower]).Value.ToExtended
  else
    aValue := 0.0;
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: TJsonArray);
begin

end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: TJsonObject);
begin

end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: Double);
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := (FIndex.items[aParam.ToLower]).Value.ToDouble
  else
    aValue := 0.0;
end;

procedure TJanuaJsonParser.JsonValue(aParam: string; var aValue: boolean);
var
  s: TJSONString;
begin
  if (FIndex.count > 0) and FIndex.ContainsKey(aParam.ToLower) then
    aValue := FIndex.items[aParam.ToLower].Value.ToBoolean
  else
    aValue := false;
end;

procedure TJanuaJsonParser.SetasJsonObject(const Value: TJsonObject);
{$ifdef delphixe}
var
  i: integer;
  aPair: TJsonPair;
  tmp: string;
begin
  FasJsonObject := Value;
  if Assigned(FasJsonObject) then
  begin
    self.FIndex.Clear;
    for i := 0 to FasJsonObject.count - 1 do
    begin
      aPair := FasJsonObject.Pairs[i];
      // Before: FasJsonObject.Get(i)
      tmp := aPair.JsonString.Value.ToLower;
      self.FIndex.Add(tmp, aPair.JsonValue);
    end;
  end;
{$endif}
{$ifdef fpc}
var
   i : integer;
begin
  if Assigned(FasJsonObject) then
  begin
    self.FIndex.Clear;
    for i := 0 to FasJsonObject.count - 1 do
    begin
      {
      aPair := FasJsonObject.Pairs[i];
      tmp := aPair.JsonString.Value.ToLower;
      self.FIndex.Add(tmp, aPair.JsonValue);
      }
    end;
  end;
{$endif}
end;

procedure TJanuaJsonParser.SetAsJsonString(const Value: string);
begin
  FAsJsonString := Value;
end;

{ TJanuaLoginRecord }

procedure TJanuaLoginRecord.Clear;
begin
  self.Session.Clear;
  self.UserProfile.Clear;
end;

function TJanuaLoginRecord.GetIsLoggedIn: boolean;
begin
  Result := self.Session.Session_id > 0
end;

function TJanuaLoginRecord.GetIsPublicSession: boolean;
begin
  Result := self.Session.isPublic
end;

function TJanuaLoginRecord.GetJsonObject: TJsonObject;
begin
  Result := TJsonObject.Create;
  Janua.Core.Functions.JsonPair(Result, 'isloggedin', self.IsLoggedIn);
  Janua.Core.Functions.JsonPair(Result, 'session', self.Session.asJsonObject);
  Janua.Core.Functions.JsonPair(Result, 'userprofile', self.UserProfile.asJsonObject);
end;

procedure TJanuaLoginRecord.LoadFromJsonObject(aJsonObject: TJsonObject);
begin
  if Assigned(aJsonObject) then
  begin
    Session.asJsonObject := Janua.Core.Functions.JsonObject('session', aJsonObject);
    UserProfile.asJsonObject := Janua.Core.Functions.JsonObject('userprofile', aJsonObject);
    // Janua.Core.Functions.JsonValue(aJsonObject, 'isloggedin', self.IsLoggedIn);
  end;
end;

procedure TJanuaLoginRecord.SetIsLoggedIn(const Value: boolean);
begin
  self.Session.Session_id := 0;
end;

{ TJanuaCoreComponentSettings }

procedure TJanuaCoreComponentSettings.SetTestMode(const Value: boolean);
begin
  FTestMode := Value;
  TJanuaCoreComponent.SetGlobalTestmode(Value);
end;

{ TJanuaConfValue }

procedure TJanuaConfValue.Clear;
begin
  self.Key := '';
  self.iValue := 0;
  self.sValue := '';
  self.dValue := 0.0;
  self.bValue := false;
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: Int64);
begin
  self.Clear;
  self.Key := aKey;
  self.lValue := aValue;
  self.ValueType := TJanuaConfType.jcfLargeInt
end;

constructor TJanuaConfValue.Create(aKey, aValue: string);
begin
  self.Clear;
  self.Key := aKey;
  self.sValue := aValue;
  self.ValueType := TJanuaConfType.jcfString
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: integer);
begin
  self.Clear;
  self.Key := aKey;
  self.iValue := aValue;
  self.ValueType := TJanuaConfType.jcfInteger
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: TDate);
begin
  self.Clear;
  self.Key := aKey;
  self.dtValue := aValue;
  self.ValueType := TJanuaConfType.jcfDate
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: TDateTime);
begin
  self.Clear;
  self.Key := aKey;
  self.dttValue := aValue;
  self.ValueType := TJanuaConfType.jcfDateTime
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: boolean);
begin
  self.Clear;
  self.Key := aKey;
  self.bValue := aValue;
  self.ValueType := TJanuaConfType.jcfBoolean
end;

function TJanuaConfValue.getAsInteger: integer;
begin
  Result := self.iValue;
end;

function TJanuaConfValue.getAsJsonObject: TJsonObject;
begin
  Result := TJsonObject.Create;

  Janua.Core.Functions.JsonPair(Result, 'key', self.Key);

  Janua.Core.Functions.JsonPair(Result, 'type', JanuaConfType[self.ValueType]);

  case self.ValueType of
    jcfString:
      Janua.Core.Functions.JsonPair(Result, 'value', self.sValue);
    jcfBoolean:
      Janua.Core.Functions.JsonPair(Result, 'value', self.bValue);
    jcfInteger:
      Janua.Core.Functions.JsonPair(Result, 'value', self.iValue);
    jcfDouble:
      Janua.Core.Functions.JsonPair(Result, 'value', self.dValue);
    jcfDate:
      Janua.Core.Functions.JsonPair(Result, 'value', self.dtValue);
    jcfDateTime:
      Janua.Core.Functions.JsonPair(Result, 'value', self.dttValue);
  end;

end;

function TJanuaConfValue.getAsString: string;
begin
  case self.ValueType of
    jcfString:
      Result := self.sValue;
    jcfBoolean:
      Result := bValue.ToString(true);
    jcfInteger:
      Result := self.iValue.ToString;
    jcfLargeInt:
      Result := self.lValue.ToString;
    jcfDouble:
      Result := self.dValue.ToString;
    jcfDate:
      Result := JsonEncodeDate(self.dtValue);
    jcfDateTime:
      Result := JsonEncodeDate(self.dttValue);
  end;

end;

procedure TJanuaConfValue.setAsInteger(const Value: integer);
begin
  self.ValueType := TJanuaConfType.jcfInteger;
  self.iValue := Value;
end;

procedure TJanuaConfValue.SetasJsonObject(const Value: TJsonObject);
var
  sType: string;
begin
  self.Clear;
  // per prima cosa imposto la 'chiave di ricerca' .....................................................................
  Janua.Core.Functions.JsonValue(Value, 'key', Key);
  Janua.Core.Functions.JsonValue(Value, 'type', sType);
  self.ValueType := DecodeJanuaConfType(sType);

  // a seconda del tipo di parametro vado a 'riempire' il giusto valore in casella .....................................
  case self.ValueType of
    jcfString:
      Janua.Core.Functions.JsonValue(Value, 'value', self.FsValue);
    jcfBoolean:
      Janua.Core.Functions.JsonValue(Value, 'value', self.bValue);
    jcfInteger:
      Janua.Core.Functions.JsonValue(Value, 'value', self.iValue);
    jcfDouble:
      Janua.Core.Functions.JsonValue(Value, 'value', self.dValue);
    jcfDate:
      Janua.Core.Functions.JsonValue(Value, 'value', self.dtValue);
    jcfDateTime:
      Janua.Core.Functions.JsonValue(Value, 'value', self.dttValue);
  end;

end;

procedure TJanuaConfValue.setAsString(const Value: string);
begin

end;

procedure TJanuaConfValue.SetsValue(const Value: string);
begin
  FsValue := Value;
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: TJsonObject);
begin
  self.Key := aKey;
  SetasJsonObject(aValue);
end;

constructor TJanuaConfValue.Create(aKey: string; aValue: TJanuaServerRecordConfs);
begin
  self.rcValue := aValue;
  self.Key := aKey;
end;

{ TJanuaConfiguration }

procedure TJanuaConfiguration.AddKey(aKey: TJanuaConfKey);
begin
  if not self.FindKey(aKey.Key) then
  begin
    SetLength(self.Keys, self.count + 1);
    self.Keys[Pred(self.count)] := aKey;
  end
end;

procedure TJanuaConfiguration.AddKey(aKey: TJsonObject);
var
  vKey: TJanuaConfKey;
begin
  vKey.asJsonObject := aKey;
  self.AddKey(vKey);
end;

function TJanuaConfiguration.asJson: string;
var
  aJson: TJsonObject;
begin
  aJson := self.asJsonObject;
  Result := aJson.{$ifdef delphixe}ToJSON{$else}AsJson{$endif};
  aJson.Free;
end;

function TJanuaConfiguration.asJsonPretty: string;
begin
  if self.count > 0 then
    Result := JsonPretty(asJson)
  else
    Result := asJson;
end;

function TJanuaConfiguration.AsJsonString: string;
begin
  Result := self.asJsonObject.ToString;
end;

procedure TJanuaConfiguration.AddKey(sKey: string);
begin
  if not self.FindKey(sKey) then
  begin
    SetLength(self.Keys, self.count + 1);
    self.Keys[Pred(self.count)].Key := sKey;
  end;
end;

procedure TJanuaConfiguration.Clear;
begin
  ClearKeys;
  FileName := '';
  LastErrorMessage := '';
  HasErrors := false;
end;

function TJanuaConfiguration.count: integer;
begin
  Result := Length(self.Keys);
end;

constructor TJanuaConfiguration.Create(aFileName: TFileName);
begin
  self.Clear;
  self.FileName := aFileName;
  self.LoadFromFile(aFileName);
end;

function TJanuaConfiguration.FindKey(aKey: string): boolean;
var
  i: integer;
begin
  Result := false;
  for i := Low(Keys) to High(Keys) do
    if Keys[i].Key.ToLower = aKey.ToLower then
    begin
      self.ItemIndex := i;
      Result := true;
      Exit(true)
    end;
end;

function TJanuaConfiguration.FindValue(aKey, aValue: string): boolean;
begin
  Result := false;
  if self.FindKey(aKey) then
    Result := self.Keys[ItemIndex].FindValue(aValue);
end;

function TJanuaConfiguration.getAsJsonObject: TJsonObject;
var
  aArray: TJsonArray;
  aItem: TJanuaConfKey;
begin
  Result := TJsonObject.Create;
  Janua.Core.Functions.JsonPair(Result, 'count', self.count);

  if self.count > 0 then
  begin
    aArray := TJsonArray.Create;
    for aItem in self.Keys do
     {$ifdef delphixe} aArray.AddElement(aItem.asJsonObject); {$endif}
     {$ifdef fpc}  aArray.Add(aItem.asJsonObject); {$endif}
    Janua.Core.Functions.JsonPair(Result, 'items', aArray);
  end;

end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: Int64): Int64;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
        Result := self.Keys[ItemIndex].SelectedItem.lValue
      else
      begin
        Result := aDefault;
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end

  end;
end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: integer): integer;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
        Result := self.Keys[ItemIndex].SelectedItem.iValue
      else
      begin
        Result := aDefault;
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;
end;

function TJanuaConfiguration.getValue(aKey, aName, aDefault: string): string;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        Result := IfThen(Keys[ItemIndex].SelectedItem.sValue = '', aDefault,
          Keys[ItemIndex].SelectedItem.sValue)
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;
end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: TDateTime): TDateTime;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
        Result := self.Keys[ItemIndex].SelectedItem.dttValue
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;
end;

procedure TJanuaConfiguration.ClearKeys;
begin
  self.ItemIndex := -1;
  SetLength(self.Keys, 0);
end;

procedure TJanuaConfiguration.Initialize;
begin
  try
    self.Clear;
    self.FileName := TJanuaCoreOS.GetConfigFileName;
    self.FIsLoaded := false;
  except
    on E: Exception do
      Janua.Core.Functions.RaiseException('TJanuaConfiguration.Initialize', E, nil);
  end;
end;

function TJanuaConfiguration.isLoaded: boolean;
begin
  Result := self.FIsLoaded;
end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: boolean): boolean;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
        Result := self.Keys[ItemIndex].SelectedItem.bValue
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: TDate): TDate;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
        Result := self.Keys[ItemIndex].SelectedItem.dtValue
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: Double): Double;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
        Result := self.Keys[ItemIndex].SelectedItem.dValue
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

procedure TJanuaConfiguration.LoadConfiguration(aFileName: TFileName);
begin
  self.FileName := aFileName;
  self.LoadConfiguration;
end;

procedure TJanuaConfiguration.LoadConfiguration;
var
 {$ifdef delphixe} sr: TStreamReader; {$endif}
  aList: TStringList;
  aFileName: TFileName;
begin
  aFileName := self.FileName;
  if FileExists(aFileName) then
  begin
    {$ifdef delphixe}
    sr := TStreamReader.Create(aFileName, TEncoding.UTF8);
    try
    {$endif}
      aList := TStringList.Create;
      try
       {$ifdef delphixe}
        while not sr.EndOfStream do
          aList.Add(sr.ReadLine);
        {$endif}
        {$ifdef fpc} aList.LoadFromFile(aFileName); {$endif}
        if aList.Text <> '' then
          self.asJsonObject := Janua.Core.Functions.JsonParse(aList.Text);
      finally
        aList.Free;
      end;
    {$ifdef delphixe}
    finally
      sr.Free;
    end;
    {$endif}
  end
  else
    self.SaveConfiguration;

  self.FIsLoaded := true;
end;

procedure TJanuaConfiguration.LoadFromFile(aFileName: TFileName);
begin
  self.FileName := aFileName;
  self.LoadConfiguration;
end;

procedure TJanuaConfiguration.SaveConfiguration;
{$ifdef delphixe}
var
  sw: TStreamWriter;
  aFileName: string;
begin
  // sovrascrive il file se esistente .................................................................................
  aFileName := self.FileName;
  if (aFileName <> '') then
  begin
    sw := TStreamWriter.Create(aFileName, false, TEncoding.UTF8);
    try
      try
        sw.WriteLine(self.asJsonPretty);
      except
        on E: Exception do
        begin
          self.HasErrors := true;
          self.LastErrorMessage := E.Message;
        end;
      end;
    finally
      sw.Free;
    end;
  end;
{$endif}
{$ifdef fpc}
begin
{$endif}
end;

procedure TJanuaConfiguration.SaveConfiguration(aFileName: TFileName);
begin
  self.FileName := aFileName;
  self.SaveConfiguration;
end;

procedure TJanuaConfiguration.SetasJsonObject(const Value: TJsonObject);
var
  aValue: TJsonValue;
  {$ifdef delphixe}  aPair: TJsonPair; {$endif}
  aObject: TJsonObject;
  vTest: integer;
begin
  self.ClearKeys;
  Janua.Core.Functions.JsonValue(Value, 'count', vTest);
  if vTest > 0 then
  begin
    {$ifdef delphixe}
    aPair := Value.Get('items');
    if Assigned(aPair) then
      for aValue in (aPair.JsonValue as TJsonArray) do
      begin
        aObject := (aValue as TJsonObject);
        self.AddKey(aObject);
      end;
    {$endif}
  end;
end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: Int64): Int64;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.lValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].lValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: integer): integer;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.iValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].iValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.setValue(aKey, aName, aDefault: string): string;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.sValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].sValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: TDateTime): TDateTime;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.dttValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].dttValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

procedure TJanuaConfiguration.UnLoad;
begin
  self.FIsLoaded := false;
  self.Clear;
end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: boolean): boolean;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.bValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].bValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: TDate): TDate;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.dValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].dValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: Double): Double;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.dValue <> aDefault then
        begin
          self.Keys[ItemIndex].items[ItemIndex].dValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: TJsonObject): TJsonObject;
var
  cKey: TJanuaConfKey;
  aConfValue: TJanuaConfValue;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        aConfValue := Keys[ItemIndex].SelectedItem;
        if (aConfValue.sValue <> JsonPretty(aDefault)) then
        begin
          self.Keys[ItemIndex].items[ItemIndex].sValue := Janua.Core.Functions.JsonPretty(aDefault);
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: TJsonObject): TJsonObject;
var
  cKey: TJanuaConfKey;
  aConfValue: TJanuaConfValue;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        aConfValue := Keys[ItemIndex].SelectedItem;
        if aConfValue.sValue <> Janua.Core.Functions.JsonPretty(aDefault) then
        begin
          self.Keys[ItemIndex].items[ItemIndex].sValue := Janua.Core.Functions.JsonPretty(aDefault);
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;
end;

function TJanuaConfiguration.getValue(aKey, aName: string; aDefault: TJanuaServerRecordConfs)
  : TJanuaServerRecordConfs;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.rcValue.Equals(aDefault) then
        begin
          self.Keys[ItemIndex].items[ItemIndex].rcValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;
end;

function TJanuaConfiguration.setValue(aKey, aName: string; aDefault: TJanuaServerRecordConfs)
  : TJanuaServerRecordConfs;
var
  cKey: TJanuaConfKey;
begin
  Result := aDefault;
  if self.FIsLoaded then
  begin
    if not self.FindKey(aKey) then
    begin
      cKey.Create(aKey);
      cKey.AddItem(aName, aDefault);
      self.AddKey(cKey);
      self.SaveConfiguration;
    end
    else
    begin
      if self.Keys[ItemIndex].FindValue(aName) then
      begin
        if self.Keys[ItemIndex].SelectedItem.rcValue.Equals(aDefault) then
        begin
          self.Keys[ItemIndex].items[ItemIndex].rcValue := aDefault;
          SaveConfiguration;
        end;
      end
      else
      begin
        self.Keys[ItemIndex].AddItem(aName, aDefault);
        self.SaveConfiguration;
      end;
    end;
  end;

end;

{ TJanuaConfKey }

procedure TJanuaConfKey.AddItem(aKey: string; aValue: integer);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfInteger;
    self.items[ItemIndex].iValue := aValue;
  end;
end;

procedure TJanuaConfKey.AddDate(aKey: string; aValue: TDate);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfDate;
    self.items[ItemIndex].dtValue := aValue;
  end;

end;

procedure TJanuaConfKey.AddItem(aKey, aValue: string);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfDate;
    self.items[ItemIndex].sValue := aValue;
  end;

end;

procedure TJanuaConfKey.AddItem(aKey: string; aValue: Int64);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfLargeInt;
    self.items[ItemIndex].lValue := aValue;
  end;

end;

procedure TJanuaConfKey.AddItem(aKey: string; aValue: TDateTime);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfDateTime;
    self.items[ItemIndex].dttValue := aValue;
  end;

end;

procedure TJanuaConfKey.AddItem(aItem: TJanuaConfValue);
begin
  SetLength(self.items, self.count + 1);
  self.items[Pred(self.count)] := aItem;
end;

procedure TJanuaConfKey.Clear;
begin
  self.Key := '';
  self.ItemIndex := -1;
  SetLength(self.items, 0);
end;

function TJanuaConfKey.count: integer;
begin
  Result := Length(self.items);
end;

constructor TJanuaConfKey.Create(aJsonObject: TJsonObject);
begin
  self.Clear;
  self.asJsonObject := aJsonObject;
end;

constructor TJanuaConfKey.Create(aKey: string; aItem: TJanuaConfValue);
begin
  self.Clear;
  self.Key := aKey;
  self.AddItem(aItem);
end;

constructor TJanuaConfKey.Create(aKey: string);
begin
  self.Clear;
  self.Key := aKey;
end;

function TJanuaConfKey.FindValue(aKey: string): boolean;
var
  i: integer;
begin
  Result := false;
  for i := Low(items) to High(items) do
    if self.items[i].Key.ToLower = aKey.ToLower then
    begin
      self.ItemIndex := i;
      Result := true;
      Exit(true)
    end;
end;

function TJanuaConfKey.getAsJsonObject: TJsonObject;
var
  aItem: TJanuaConfValue;
  aArray: TJsonArray;
begin
  Result := TJsonObject.Create;
  Janua.Core.Functions.JsonPair(Result, 'key', self.Key);
  Janua.Core.Functions.JsonPair(Result, 'count', self.count);
  if self.count > 0 then
  begin
    aArray := TJsonArray.Create;

    for aItem in self.items do
    {$ifdef delphixe}
      aArray.AddElement(aItem.asJsonObject);
    {$endif}
    {$ifdef fpc}
      aArray.Add(aItem.asJsonObject);
    {$endif}

    Janua.Core.Functions.JsonPair(Result, 'items', aArray);
  end;

end;

function TJanuaConfKey.getSelectedItem: TJanuaConfValue;
begin
  if self.ItemIndex >= 0 then
    Result := self.items[self.ItemIndex]
  else if self.count > 0 then
    Result := self.items[0];
end;

procedure TJanuaConfKey.SetasJsonObject(const Value: TJsonObject);
var
  aValue: TJsonValue;
  {$ifdef delphixe}aPair: TJsonPair;{$endif}
  aObject: TJsonObject;
  vTest: integer;
begin
  Clear;
  // temporaneamente movimento solo l'array di items ma non le righe di template
  {
    self.SecondLineChar := aJson.GetValue('SecondLineChar').Value;
    self.TemplateHeader := aJson.GetValue('TemplateHeader').Value;
    self.TemplateRow := aJson.GetValue('TemplateRow').Value;
  }

  Janua.Core.Functions.JsonValue(Value, 'key', self.Key);
  Janua.Core.Functions.JsonValue(Value, 'count', vTest);
  if vTest > 0 then
  begin
    {$ifdef delphixe}
    aPair := Value.Get('items');
    if Assigned(aPair) then
      for aValue in (aPair.JsonValue as TJsonArray) do
      begin
        aObject := (aValue as TJsonObject);
        self.AddItem(aObject);
      end;
    {$endif}

  end;

end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: TJsonObject);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].sValue := Janua.Core.Functions.JsonPretty(aValue);
end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: boolean);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].bValue := aValue;
end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: Int64);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].lValue := aValue;
end;

procedure TJanuaConfKey.SetItem(aKey, aValue: string);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].sValue := aValue;
end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: integer);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].iValue := aValue;
end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: TDateTime);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].dttValue := aValue;

end;

procedure TJanuaConfKey.SetSelectedItem(const Value: TJanuaConfValue);
begin
  self.items[ItemIndex] := Value;
end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: TDate);
begin
  if self.FindValue(aKey) then
    self.items[ItemIndex].dtValue := aValue;
end;

procedure TJanuaConfKey.AddItem(aKey: string; aValue: boolean);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfBoolean;
    self.items[ItemIndex].bValue := aValue;
  end;

end;

procedure TJanuaConfKey.AddItem(aObject: TJsonObject);
var
  aItem: TJanuaConfValue;
begin
  aItem.asJsonObject := aObject;
  self.AddItem(aItem);
end;

procedure TJanuaConfKey.AddItem(aKey: string; aValue: TJsonObject);
begin

end;

procedure TJanuaConfKey.AddItem(aKey: string; aValue: TJanuaServerRecordConfs);
var
  aItem: TJanuaConfValue;
begin
  if not self.FindValue(aKey) then
  begin
    aItem.Create(aKey, aValue);
    AddItem(aItem);
  end
  else
  begin
    self.items[ItemIndex].ValueType := TJanuaConfType.jcfServerConf;
    self.items[ItemIndex].rcValue := aValue;
  end;

  aItem.Key := aKey;
  aItem.rcValue := aValue;
  self.AddItem(aItem);

end;

procedure TJanuaConfKey.SetItem(aKey: string; aValue: TJanuaServerRecordConfs);
begin

end;

{ TJanuaCustomRESTModel }

procedure TJanuaCustomRESTModel.SetJanuaRESTClient(const Value: TJanuaCustomRESTClient);
begin
  FJanuaRESTClient := Value;
end;

{ TJanuaCoreLogger }

procedure TJanuaCoreLogger.SetIsCustomServer(const Value: boolean);
begin
  inherited;
end;

procedure TJanuaCoreLogger.SetJanuaOS(const Value: TJanuaCoreOS);
begin
  inherited;
end;

procedure TJanuaCoreLogger.SetLogType(const Value: TJanuaLogType);
begin
  inherited;
end;

{ TJanuaImageRSSTag }

constructor TJanuaImageRSSTag.Create(aFeedType: TJanuaRSSFeedType);
begin
  self.SetDefault;
end;

procedure TJanuaImageRSSTag.SetDefault;
begin
  // this sets the tags at their defaults according to the RSS 2.1 Specifications
  {
    <image>
    <link>http://dallas.example.com</link>
    <title>Dallas Times-Herald</title>
    <url>http://dallas.example.com/masthead.gif</url>
    <description>Read the Dallas Times-Herald</description>
    <height>32</height>
    <width>96</width>
    </image>
  }
  Image := 'image';
  Description := 'description';
  Url := 'url';
  Title := 'title';
  Link := 'link';
  Width := 'width';
  Heigth := 'width';
end;

{ TJanuaItemRSSTag }

constructor TJanuaItemRSSTag.Create(aFeedType: TJanuaRSSFeedType);
begin
  self.SetDefault;
end;

procedure TJanuaItemRSSTag.SetDefault;
begin
  {
    <item>
    <title>Seventh Heaven! Ryan Hurls Another No Hitter</title>
    <link>http://dallas.example.com/1991/05/02/nolan.htm</link>
    <description>Texas Rangers pitcher Nolan Ryan hurled the seventh no-hitter of his legendary career ...</description>
    <author>jbb@dallas.example.com</author>
    <category>rec.arts.movies.reviews</category>
    <comments>http://dallas.example.com/feedback/1983/06/joebob.htm</comments>
    <description>I'm headed for France. I wasn't gonna go this year, but then last week &lt;a
    href="http://www.imdb.com/title/tt0086525/"&gt;Valley Girl&lt;/a&gt; came out and I said to myself,
    Joe Bob, you gotta get out of the country for a while.</description>
    <description><![CDATA[I'm headed for France. I wasn't gonna go this year, but then last week
    <a href="http://www.imdb.com/title/tt0086525/">Valley Girl</a> came out and I said to myself, Joe Bob,
    you gotta get out of the country for a while.]]></description>
    <enclosure length="24986239" type="audio/mpeg" url="http://dallas.example.com/joebob_050689.mp3" />
    </item>

    title	The title of the item.	Venice Film Festival Tries to Quit Sinking
    link	The URL of the item.	http://nytimes.com/2004/12/07FEST.html
    description	The item synopsis.	<description>Some of the most heated chatter at the Venice ...</description>
    author	Email address of the author of the item. More.
    category	Includes the item in one or more categories. More.
    comments	URL of a page for comments relating to the item. More.
    enclosure	Describes a media object that is attached to the item. More.
    guid	A string that uniquely identifies the item. More.
    pubDate	Indicates when the item was published. More.
    source	The RSS channel that the item came from. More.
  }

  Item := 'item';
  Title := 'title';
  Link := 'link';
  Author := 'author';
  Description := 'description';
  category := 'category';
  comments := 'comments';
  enclosure := 'item';
  guid := 'guid';
  pubDate := 'pubDate';
  Source := 'source';
end;

{ TJanuaCustomComponent }

procedure TJanuaCustomComponent.AddComponent(aComponent: TJanuaCustomComponent);
begin

end;

procedure TJanuaCustomComponent.AddObject(aObject: TJanuaCustomObject);
begin

end;

procedure TJanuaCustomComponent.AddPersistent(aPersistent: TJanuaCustomPersistent);
begin

end;

constructor TJanuaCustomComponent.Create(AOwner: TComponent);
begin
  inherited;
  // FComponents := TObjectList<TJanuaCustomComponent>.Create;
  // Disabilito Temporaneamnte la Gestione dei TPersistents .............................
  // FPersistents := TObjectList<TJanuaCustomPersistent>.Create;
  // FObjects := TObjectList<TJanuaCustomObject>.Create;
end;

procedure TJanuaCustomComponent.DelComponent(aComponent: TJanuaCustomComponent);
begin

end;

procedure TJanuaCustomComponent.DelObject(aObject: TJanuaCustomObject);
begin

end;

procedure TJanuaCustomComponent.DelPersistent(aPersistent: TJanuaCustomPersistent);
begin

end;

destructor TJanuaCustomComponent.Destroy;
begin
  // FPersistents.Free;
  // FObjects.Free;
  // self.FComponents.Free;
  inherited;
end;

procedure TJanuaCustomComponent.SetHasErrors(const Value: boolean);
begin
  self.FHasErrors := Value;
end;

{ TJanuaBindableObject }

{$ifdef delphixe}

procedure TJanuaBindableObject.Bind(const AProperty: string; const ABindToObject: TObject;
  const ABindToProperty: string; const AReadOnly: boolean; const ACreateOptions: TBindings.TCreateOptions);
begin
  // From source to dest
  if not AReadOnly then
    FBindings.Add(TBindings.CreateManagedBinding(
      { inputs }
      [TBindings.CreateAssociationScope([Associate(self, 'src')])], 'src.' + AProperty,
      { outputs }
      [TBindings.CreateAssociationScope([Associate(ABindToObject, 'dst')])], 'dst.' + ABindToProperty, nil,
      nil, ACreateOptions));
  // From dest to source
  FBindings.Add(TBindings.CreateManagedBinding(
    { inputs }
    [TBindings.CreateAssociationScope([Associate(ABindToObject, 'src')])], 'src.' + ABindToProperty,
    { outputs }
    [TBindings.CreateAssociationScope([Associate(self, 'dst')])], 'dst.' + AProperty, nil, nil,
    ACreateOptions));

end;



procedure TJanuaBindableObject.ClearBindings;
{ Januaproject Binding Framework .......................................................... }
var
  i: TBindingExpression;
begin
  for i in FBindings do
    TBindings.RemoveBinding(i);
  FBindings.Clear;
end;

constructor TJanuaBindableObject.Create;
begin
  inherited;
  FBindings := TExpressionList.Create(false { AOwnsObjects } );
end;

destructor TJanuaBindableObject.Destroy;
begin
  ClearBindings;
  FBindings.Free;
  inherited;
end;

procedure TJanuaBindableObject.Notify(const APropertyName: string);
begin
  TBindings.Notify(self, APropertyName);
end;
{$endif}

{ TJanuaInterfacedBindableObject }

{$ifdef fpc}
procedure TJanuaInterfacedBindableObject.ClearBindings;
begin
end;
{$endif}

{$ifdef delphixe}
procedure TJanuaInterfacedBindableObject.Bind(const AProperty: string; const ABindToObject: TObject;
  const ABindToProperty: string; const AReadOnly: boolean; const ACreateOptions: TBindings.TCreateOptions);
begin
  // From source to dest
  if not AReadOnly then
    FBindings.Add(TBindings.CreateManagedBinding(
      { inputs }
      [TBindings.CreateAssociationScope([Associate(self, 'src')])], 'src.' + AProperty,
      { outputs }
      [TBindings.CreateAssociationScope([Associate(ABindToObject, 'dst')])], 'dst.' + ABindToProperty, nil,
      nil, ACreateOptions));
  // From dest to source
  FBindings.Add(TBindings.CreateManagedBinding(
    { inputs }
    [TBindings.CreateAssociationScope([Associate(ABindToObject, 'src')])], 'src.' + ABindToProperty,
    { outputs }
    [TBindings.CreateAssociationScope([Associate(self, 'dst')])], 'dst.' + AProperty, nil, nil,
    ACreateOptions));
  self.FHasBindings := true;
end;



procedure TJanuaInterfacedBindableObject.ClearBindings;
var
  i: TBindingExpression;
begin
  try
    Guard.CheckNotNull(FBindings, self.ClassName + '.ClearBindings FBindings is not nil');
    for i in FBindings do
      TBindings.RemoveBinding(i);
    FBindings.Clear;
    self.FHasBindings := false;
  Except
    on E: Exception do
      Janua.Core.Functions.RaiseException('ClearBindings', E, self);
  end;
end;


procedure TJanuaInterfacedBindableObject.Notify(const APropertyName: string);
begin
  TBindings.Notify(self, APropertyName);
end;


procedure TJanuaInterfacedBindableObject.UnBind(const AProperty: string; const ABindToObject: TObject;
  const ABindToProperty: string);
begin
  // This procedure can delete a binding

end;

{$endif}

procedure TJanuaInterfacedBindableObject.ClearLocalLog(const aProcedureName: string);
begin
  if Assigned(FInternalLog) then
    FInternalLog.Clear;
end;

constructor TJanuaInterfacedBindableObject.Create;
begin
  {$ifdef delphixe}
  FBindings := TExpressionList.Create(false { AOwnsObjects } );
  self.FInternalLog := TCollections.CreateList<TLocalLog>;
  {$endif}
  {$ifdef fpc}
   FInternalLog := TList<TLocalLog>.Create;
  {$endif}
  self.FHasBindings := false;
end;

destructor TJanuaInterfacedBindableObject.Destroy;
begin
  ClearBindings;
   {$ifdef delphixe}  FBindings.Free; {$endif}
  inherited;
end;

function TJanuaInterfacedBindableObject.GetLogString: string;
var
  // E: Spring.Collections.IEnumerator<TLocalLog>;
  aLog: TLocalLog;
begin
  Result := '';
  if Assigned(FInternalLog) then
    try
      for aLog in FInternalLog do
        Result := Result + IfThen(Result = '', '', sLineBreak) + aLog.ToString;
      FInternalLog.Clear;
      {
        E := FInternalLog.GetEnumerator;
        if not E.MoveNext then
        Exit('');
        Result := E.Current.ToString;
        while E.MoveNext do
        Result := Result + E.Current.ToString;
      }
    except
      on E: Exception do
        Janua.Core.Functions.RaiseException('GetLogString', E, self, ' Reading Log: ');
    end;
end;

procedure TJanuaInterfacedBindableObject.SetHasBindings(const Value: boolean);
begin
  FHasBindings := Value;
end;

procedure TJanuaInterfacedBindableObject.WriteError(const aProcedureName, aLog: string; E: Exception);
begin
  TJanuaCoreOS.PublicWriteError(self, aProcedureName, aLog, E)
end;

procedure TJanuaInterfacedBindableObject.WriteLocalLog(const aProcedureName, aLog: string);
begin
  try
    Guard.CheckNotNull(FInternalLog, 'FInternal Log is nil');
    self.FInternalLog.Add(TLocalLog.Create(Now(), self.ClassName, aProcedureName, aLog));
  except
    on E: Exception do
      Janua.Core.Functions.RaiseException('WriteLocalLog', E, self, 'WriteLocalLog:' + aLog);
  end;
end;

procedure TJanuaInterfacedBindableObject.WriteLog(const aProcedureName, aLog: string);
begin
  TJanuaCoreOS.PublicWriteLog(self, aProcedureName, aLog)
end;

{ TJanuaBindableItem }

{$ifdef delphixe}
procedure TJanuaBindableItem.Bind(const AProperty: string; const ABindToObject: TObject;
  const ABindToProperty: string; const AReadOnly: boolean; const ACreateOptions: TBindings.TCreateOptions);
begin
  if not AReadOnly then
    FBindings.Add(TBindings.CreateManagedBinding(
      { inputs }
      [TBindings.CreateAssociationScope([Associate(self, 'src')])], 'src.' + AProperty,
      { outputs }
      [TBindings.CreateAssociationScope([Associate(ABindToObject, 'dst')])], 'dst.' + ABindToProperty, nil,
      nil, ACreateOptions));
  // From dest to source
  FBindings.Add(TBindings.CreateManagedBinding(
    { inputs }
    [TBindings.CreateAssociationScope([Associate(ABindToObject, 'src')])], 'src.' + ABindToProperty,
    { outputs }
    [TBindings.CreateAssociationScope([Associate(self, 'dst')])], 'dst.' + AProperty, nil, nil,
    ACreateOptions));

end;
{$endif delphixe}

procedure TJanuaBindableItem.ClearBindings;
{$ifdef delphixe}
var
  i: TBindingExpression;
begin
  for i in FBindings do
    TBindings.RemoveBinding(i);
  FBindings.Clear;
  {$else delphixe}
  begin
  {$endif delphixe}
end;

constructor TJanuaBindableItem.Create;
begin
  inherited;
    {$ifdef delphixe} FBindings := TExpressionList.Create(false { AOwnsObjects } );   {$endif delphixe}
end;

destructor TJanuaBindableItem.Destroy;
begin
  ClearBindings;
    {$ifdef delphixe} FBindings.Free;   {$endif delphixe}
  inherited;
end;

procedure TJanuaBindableItem.Notify(const APropertyName: string);
begin
    {$ifdef delphixe}  TBindings.Notify(self, APropertyName);   {$endif delphixe}
end;

{ TJanuaInterfacedBindableObject.TLocalLog }

constructor TJanuaInterfacedBindableObject.TLocalLog.Create(const aDateTime: TDateTime;
  const aClassName, aProcName, aLogMessage: string);
begin
  self.DateTime := aDateTime;
  self.ClassName := aClassName;
  self.ProcName := aProcName;
  self.LogMessage := aLogMessage;
end;

function TJanuaInterfacedBindableObject.TLocalLog.ToString: string;
begin
  Result := DateToISO8601(self.DateTime) + ' - ' + ClassName + '.' + ProcName + sl + LogMessage + sl;
end;

{ TJanuaCoreDialog }

procedure TJanuaCoreDialog.SetText(const Value: string);
begin
  FText := Value;
end;

procedure TJanuaCoreDialog.SetTitle(const Value: string);
begin
  FTitle := Value;
end;

initialization

try
  { Insert Procedures ............................... }
  JanuaApplicationGlobalProfile.Create('test.ergomercator.com');
  FJanuaConfiguration.Initialize;
  FComponentInstances := TList<TJanuaCustomComponent>.Create;
  // Component Instances = TList TJanuaCustomComponent.
  FPublicRaised := false;
  // FInitialized := False;
except
  on E: Exception do
    raise Exception.Create('Janua.Football.Web.initialization ' + E.Message);
end;


// jafServerDatasnap, jafServerWebBroker, jafMac, jafVCL, jafIOSTablet, jafIOSPhone, jafAndroidTablet, jafAndroidPhone,
// jafLinux64

finalization

FComponentInstances.Free;

end.
